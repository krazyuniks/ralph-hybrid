#!/usr/bin/env bash
# Ralph Hybrid - Main Script
# Autonomous development loop orchestrator for Claude Code
#
# Usage: ralph-hybrid <command> [options]
# Commands: run, status, archive, validate, import, help, version
#
# Note: Feature folder is automatically derived from current git branch.

set -euo pipefail

#=============================================================================
# Script Directory
#=============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

#=============================================================================
# Source Libraries
#=============================================================================

source "${SCRIPT_DIR}/lib/constants.sh"
source "${SCRIPT_DIR}/lib/theme.sh"
source "${SCRIPT_DIR}/lib/utils.sh"
source "${SCRIPT_DIR}/lib/preflight.sh"
source "${SCRIPT_DIR}/lib/circuit_breaker.sh"
source "${SCRIPT_DIR}/lib/rate_limiter.sh"
source "${SCRIPT_DIR}/lib/exit_detection.sh"
source "${SCRIPT_DIR}/lib/archive.sh"
source "${SCRIPT_DIR}/lib/monitor.sh"
source "${SCRIPT_DIR}/lib/hooks.sh"
source "${SCRIPT_DIR}/lib/import.sh"
source "${SCRIPT_DIR}/lib/lockfile.sh"
source "${SCRIPT_DIR}/lib/log_filter.sh"
source "${SCRIPT_DIR}/lib/mcp.sh"
source "${SCRIPT_DIR}/lib/debug.sh"
source "${SCRIPT_DIR}/lib/memory.sh"

#=============================================================================
# Global Variables (set by parse_args or load_config)
#=============================================================================

# Run options (use defaults from constants.sh)
RALPH_HYBRID_MAX_ITERATIONS="${RALPH_HYBRID_MAX_ITERATIONS:-$RALPH_HYBRID_DEFAULT_MAX_ITERATIONS}"
RALPH_HYBRID_TIMEOUT_MINUTES="${RALPH_HYBRID_TIMEOUT_MINUTES:-$RALPH_HYBRID_DEFAULT_TIMEOUT_MINUTES}"
RALPH_HYBRID_RATE_LIMIT="${RALPH_HYBRID_RATE_LIMIT:-$RALPH_HYBRID_DEFAULT_RATE_LIMIT}"
RALPH_HYBRID_PROMPT_FILE=""
RALPH_HYBRID_VERBOSE=false
RALPH_HYBRID_NO_ARCHIVE=false
RALPH_HYBRID_DRY_RUN=false
RALPH_HYBRID_SKIP_PREFLIGHT=false
RALPH_HYBRID_DANGEROUSLY_SKIP_PERMISSIONS="${RALPH_HYBRID_DANGEROUSLY_SKIP_PERMISSIONS:-false}"
RALPH_HYBRID_MONITOR=false

#=============================================================================
# Help / Usage
#=============================================================================

show_help() {
    cat << EOF
Ralph Hybrid - Autonomous Development Loop for Claude Code

Usage: ralph-hybrid <command> [options]

Commands:
  run [options]          Execute the development loop
  status                 Show current feature status
  monitor                Attach to monitoring dashboard for existing run
  kill                   Kill the Ralph process running in this project
  archive                Archive a completed feature
  restore                Restore a feature from archive
  validate [--smoke]     Run preflight checks (--smoke adds HTTP health checks)
  verify [options]       Run goal-backward verification on current feature
  integrate [options]    Run integration check on current feature
  debug [options]        Start or continue scientific debugging session
  setup                  Install Claude commands (/ralph-hybrid-plan, etc.) to project
  import <file>          Import PRD from Markdown or JSON file
  help                   Show this help message
  version                Show version information

Note: Feature folder is automatically derived from current git branch.
      Run 'ralph-hybrid setup' first, then use /ralph-hybrid-plan in Claude Code.

Run Options:
  -n, --max-iterations N     Maximum iterations (default: ${RALPH_HYBRID_DEFAULT_MAX_ITERATIONS})
  -t, --timeout N            Per-iteration timeout in minutes (default: ${RALPH_HYBRID_DEFAULT_TIMEOUT_MINUTES})
  -r, --rate-limit N         Max API calls per hour (default: ${RALPH_HYBRID_DEFAULT_RATE_LIMIT})
  -p, --prompt FILE          Custom prompt file
  -v, --verbose              Enable verbose output
  --no-archive               Don't archive on completion
  --dry-run                  Show what would happen without executing
  --skip-preflight           Skip preflight validation (use with caution)
  --dangerously-skip-permissions  Pass to Claude Code
  --monitor                  Launch with tmux monitoring dashboard
  -m, --model MODEL          Claude model (opus, sonnet, or full name)
  --profile PROFILE          Model profile (quality, balanced, budget; default: balanced)

Archive Options:
  -y, --yes                  Skip confirmation for deferred work warnings

Import Options:
  --format FORMAT          Override format detection (markdown, json)
  --output PATH            Output path (default: .ralph-hybrid/{branch}/prd.json)

Verify Options:
  --profile PROFILE        Model profile for verification (quality, balanced, budget)
  -m, --model MODEL        Specific model to use (overrides profile)
  -o, --output FILE        Output file (default: .ralph-hybrid/{branch}/VERIFICATION.md)
  -v, --verbose            Enable verbose output

Debug Options:
  --profile PROFILE        Model profile for debugging (quality, balanced, budget)
  -m, --model MODEL        Specific model to use (overrides profile)
  --continue               Continue from previous debug state
  --reset                  Start fresh, discarding previous debug state
  -v, --verbose            Enable verbose output

Integrate Options:
  --profile PROFILE        Model profile for integration check (quality, balanced, budget)
  -m, --model MODEL        Specific model to use (overrides profile)
  -o, --output FILE        Output file (default: .ralph-hybrid/{branch}/INTEGRATION.md)
  -v, --verbose            Enable verbose output

Examples:
  ralph-hybrid run -n 30 -t 20
  ralph-hybrid status
  ralph-hybrid archive
  ralph-hybrid validate              # Preflight checks only
  ralph-hybrid validate --smoke      # Preflight + HTTP health checks
  ralph-hybrid verify                # Run goal-backward verification
  ralph-hybrid verify --profile quality
  ralph-hybrid integrate             # Run integration check
  ralph-hybrid integrate --profile quality
  ralph-hybrid debug "tests failing after refactor"
  ralph-hybrid debug --continue             # Continue previous debug session
  ralph-hybrid import spec.md
  ralph-hybrid import requirements.json --output ./prd.json

For more information, see: https://github.com/krazyuniks/ralph-hybrid
EOF
}

show_version() {
    echo "ralph-hybrid version ${RALPH_HYBRID_VERSION}"
}

#=============================================================================
# Prerequisite Checks
#=============================================================================

# Check all required commands are available
check_prerequisites() {
    local missing=()

    if ! command -v claude &>/dev/null; then
        missing+=("claude")
    fi

    if ! command -v jq &>/dev/null; then
        missing+=("jq")
    fi

    if ! command -v git &>/dev/null; then
        missing+=("git")
    fi

    # Check for timeout command
    if ! get_timeout_cmd &>/dev/null; then
        missing+=("timeout (install coreutils on macOS)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Required commands not found: ${missing[*]}"
        log_error "Please install the missing dependencies."
        return 1
    fi

    return 0
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir &>/dev/null; then
        log_error "Not in a git repository. Please initialize git first."
        return 1
    fi
    return 0
}

# Note: get_ralph_dir() and get_feature_dir() are now provided by lib/utils.sh

#=============================================================================
# Status Command
#=============================================================================

cmd_status() {
    # No arguments expected - feature auto-detected from branch
    if [[ $# -gt 0 ]]; then
        log_error "Unknown option: $1"
        return 1
    fi

    # Get feature directory from current git branch
    local feature_dir
    feature_dir=$(get_feature_dir) || return 1

    local prd_file="${feature_dir}/prd.json"

    # Get feature name from directory for display
    local feature_name
    feature_name=$(basename "$feature_dir")

    if [[ ! -f "$prd_file" ]]; then
        log_error "prd.json not found for feature: ${feature_name}"
        return 1
    fi

    # Get story counts
    local total passed
    total=$(get_prd_total_stories "$prd_file")
    passed=$(get_prd_passes_count "$prd_file")

    # Get current branch (for display only - feature is derived from folder)
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")

    echo "=========================================="
    echo "Feature: ${feature_name}"
    echo "=========================================="
    echo "Stories: ${passed}/${total} complete"
    echo "Current branch: ${current_branch}"
    echo ""

    # Show circuit breaker state if it exists
    export RALPH_HYBRID_STATE_DIR="${feature_dir}"
    if [[ -f "${feature_dir}/circuit_breaker.state" ]]; then
        cb_load_state
        cb_get_status
    else
        echo "Circuit Breaker: Not initialized"
    fi
    echo ""

    # Show stories
    echo "Stories:"
    jq -r '.userStories[] | "  [\(if .passes then "X" else " " end)] \(.id): \(.title)"' "$prd_file"

    return 0
}

#=============================================================================
# Archive Command
#=============================================================================

cmd_archive() {
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -y|--yes)
                force=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Get feature directory from current git branch
    local feature_dir
    feature_dir=$(get_feature_dir) || return 1

    local ralph_dir
    ralph_dir=$(get_ralph_dir)

    # Get feature name from directory
    local feature_name
    feature_name=$(basename "$feature_dir")

    local prd_file="${feature_dir}/prd.json"

    # Check for deferred work before archiving
    local deferred_stories
    if deferred_stories=$(ar_check_deferred_work "$prd_file"); then
        if [[ "$force" != true ]]; then
            if ! ar_warn_deferred_work "$deferred_stories"; then
                log_info "Archive cancelled."
                return 1
            fi
        else
            log_warn "Deferred work detected but proceeding due to -y/--yes flag:"
            echo "$deferred_stories" | while IFS= read -r line; do
                echo "  - $line"
            done
        fi
    fi

    # Use archive library
    local archive_path
    archive_path=$(ar_create_archive "$feature_name" "$ralph_dir") || return 1

    # Remove original
    ar_cleanup_feature "$feature_name" "$ralph_dir" || return 1

    log_success "Feature archived to: ${archive_path}"

    # Commit the archive to preserve it in git history
    # This ensures the archive data (for retrospective analysis) is not accidentally deleted
    if git rev-parse --git-dir >/dev/null 2>&1; then
        log_info "Committing archive to git..."
        git add "${ralph_dir}/archive/" 2>/dev/null || true
        # Also stage the deletion of the working feature folder
        git add -A "${ralph_dir}/" 2>/dev/null || true
        if ! git diff --cached --quiet 2>/dev/null; then
            git commit -m "chore: Archive completed feature ${feature_name}" >/dev/null 2>&1 || {
                log_warn "Could not commit archive (may need manual commit)"
            }
        fi
    fi

    return 0
}

#=============================================================================
# Monitor Command
#=============================================================================

cmd_monitor() {
    # No arguments expected
    if [[ $# -gt 0 ]]; then
        log_error "Unknown option: $1"
        return 1
    fi

    # Use monitor library to attach to existing session
    mon_attach
    return $?
}

#=============================================================================
# Kill Command
#=============================================================================

cmd_kill() {
    # No arguments expected
    if [[ $# -gt 0 ]]; then
        log_error "Unknown option: $1"
        return 1
    fi

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Get feature directory from current git branch
    local feature_dir
    feature_dir=$(get_feature_dir) || return 1

    # Get absolute path
    local abs_feature_dir
    abs_feature_dir="$(cd "$(dirname "$feature_dir")" && pwd)/$(basename "$feature_dir")"

    # Generate lockfile name
    local filename
    filename="${abs_feature_dir//\//__}"
    filename="${filename#__}.lock"
    local lockfile="${HOME}/.ralph-hybrid/lockfiles/${filename}"

    # Check if lockfile exists
    if [[ ! -f "$lockfile" ]]; then
        log_error "No Ralph process found for this project"
        log_info "Feature: $abs_feature_dir"
        log_info "Expected lockfile: $lockfile"
        return 1
    fi

    # Read PID from lockfile
    local pid
    pid=$(head -1 "$lockfile" 2>/dev/null)

    if [[ -z "$pid" ]]; then
        log_error "Could not read PID from lockfile"
        rm -f "$lockfile"
        return 1
    fi

    # Check if process is running
    if ! kill -0 "$pid" 2>/dev/null; then
        log_warn "Process $pid is not running (stale lock)"
        rm -f "$lockfile"
        log_info "Cleaned up stale lockfile"
        return 0
    fi

    # Kill the process and its children
    log_info "Killing Ralph process $pid and its children..."

    # Get all child PIDs
    local children
    children=$(pgrep -P "$pid" 2>/dev/null || true)

    # Kill main process
    kill -TERM "$pid" 2>/dev/null || true
    sleep 0.5

    # Kill children if still running
    if [[ -n "$children" ]]; then
        echo "$children" | xargs kill -TERM 2>/dev/null || true
        sleep 0.5
        echo "$children" | xargs kill -KILL 2>/dev/null || true
    fi

    # Force kill main process if still alive
    if kill -0 "$pid" 2>/dev/null; then
        kill -KILL "$pid" 2>/dev/null || true
    fi

    # Also kill any remaining claude processes
    pkill -f "claude -p --permission-mode" 2>/dev/null || true

    # Remove lockfile
    rm -f "$lockfile"

    # Verify it's dead
    sleep 0.3
    if kill -0 "$pid" 2>/dev/null; then
        log_error "Failed to kill process $pid"
        return 1
    else
        log_success "Successfully killed Ralph process $pid"
        return 0
    fi
}

#=============================================================================
# Validate Command
#=============================================================================

cmd_validate() {
    local run_smoke=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --smoke)
                run_smoke=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Usage: ralph-hybrid validate [--smoke]"
                return 1
                ;;
        esac
    done

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Run all preflight checks (feature_dir auto-detected from branch)
    pf_run_all_checks || return $?

    # Run smoke tests if requested
    if [[ "$run_smoke" == true ]]; then
        _validate_run_smoke_tests
        return $?
    fi

    return 0
}

# Run smoke tests to verify the application is accessible
# Detects port from docker-compose.override.yml or worktree.py
_validate_run_smoke_tests() {
    log_info "Running smoke tests..."

    # Try to detect the backend port
    local backend_port=""

    # Method 1: docker-compose.override.yml
    if [[ -f "docker-compose.override.yml" ]]; then
        backend_port=$(grep -E '^\s*-\s*"?[0-9]+:8' docker-compose.override.yml 2>/dev/null | head -1 | sed -E 's/.*"?([0-9]+):.*/\1/')
    fi

    # Method 2: worktree.py output (look for backend port in output)
    if [[ -z "$backend_port" ]] && [[ -f "./worktree.py" ]]; then
        backend_port=$(./worktree.py 2>/dev/null | grep -i backend | grep -oE '[0-9]{4,5}' | head -1)
    fi

    # Method 3: .worktree/config or similar
    if [[ -z "$backend_port" ]] && [[ -f ".worktree/config" ]]; then
        backend_port=$(grep -i backend_port .worktree/config 2>/dev/null | grep -oE '[0-9]+' | head -1)
    fi

    # Fallback to common defaults
    if [[ -z "$backend_port" ]]; then
        log_warn "Could not detect backend port. Trying common ports..."
        for port in 8020 8000 8080 3000; do
            if curl -sf "http://localhost:${port}/health" >/dev/null 2>&1; then
                backend_port=$port
                break
            fi
        done
    fi

    if [[ -z "$backend_port" ]]; then
        log_error "Could not detect or find active backend port"
        log_info "Ensure your application is running and port is configured"
        return 1
    fi

    local base_url="http://localhost:${backend_port}"
    log_info "Using backend URL: $base_url"

    local failed=0
    local passed=0

    # Health check
    echo -n "  Health check ($base_url/health)... "
    if curl -sf "${base_url}/health" >/dev/null 2>&1; then
        echo "✓"
        ((passed++))
    else
        echo "✗"
        ((failed++))
    fi

    # Homepage check
    echo -n "  Homepage ($base_url/)... "
    local http_code
    http_code=$(curl -sf -o /dev/null -w "%{http_code}" "${base_url}/" 2>/dev/null)
    if [[ "$http_code" == "200" ]] || [[ "$http_code" == "302" ]]; then
        echo "✓ ($http_code)"
        ((passed++))
    else
        echo "✗ ($http_code)"
        ((failed++))
    fi

    # Check key pages if they exist (configurable via .ralph-hybrid/smoke-pages.txt)
    local feature_dir
    feature_dir=$(get_feature_dir 2>/dev/null) || true

    if [[ -n "$feature_dir" ]] && [[ -f "${feature_dir}/smoke-pages.txt" ]]; then
        while IFS= read -r page || [[ -n "$page" ]]; do
            [[ -z "$page" || "$page" == \#* ]] && continue
            echo -n "  Page ${page}... "
            http_code=$(curl -sf -o /dev/null -w "%{http_code}" "${base_url}${page}" 2>/dev/null)
            if [[ "$http_code" == "200" ]] || [[ "$http_code" == "302" ]] || [[ "$http_code" == "301" ]]; then
                echo "✓ ($http_code)"
                ((passed++))
            else
                echo "✗ ($http_code)"
                ((failed++))
            fi
        done < "${feature_dir}/smoke-pages.txt"
    fi

    echo ""
    if [[ $failed -eq 0 ]]; then
        log_success "Smoke tests passed: $passed checks"
        return 0
    else
        log_error "Smoke tests failed: $failed failures, $passed passed"
        return 1
    fi
}

#=============================================================================
# Restore Command
#=============================================================================

cmd_restore() {
    # Optional: archive name or timestamp
    local archive_name="${1:-}"

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Get feature directory from current git branch
    local feature_dir
    feature_dir=$(get_feature_dir) || return 1

    local ralph_dir
    ralph_dir=$(get_ralph_dir)

    local feature_name
    feature_name=$(basename "$feature_dir")

    local archive_dir="${ralph_dir}/archive"

    # Check if archive directory exists
    if [[ ! -d "$archive_dir" ]]; then
        log_error "No archive directory found at: $archive_dir"
        return 1
    fi

    # Find matching archives
    local matching_archives=()
    if [[ -n "$archive_name" ]]; then
        # User specified an archive
        if [[ -d "${archive_dir}/${archive_name}" ]]; then
            matching_archives=("${archive_dir}/${archive_name}")
        fi
    else
        # Find all archives for this feature (sorted by date, newest first)
        while IFS= read -r archive; do
            matching_archives+=("$archive")
        done < <(find "$archive_dir" -maxdepth 1 -type d -name "*-${feature_name}" | sort -r)
    fi

    # Check if we found any archives
    if [[ ${#matching_archives[@]} -eq 0 ]]; then
        log_error "No archives found for feature: $feature_name"
        log_info "Archive directory: $archive_dir"
        return 1
    fi

    # Use the most recent archive
    local source_archive="${matching_archives[0]}"
    local archive_basename
    archive_basename=$(basename "$source_archive")

    log_info "Restoring from archive: $archive_basename"

    # Check if feature directory already exists
    if [[ -d "$feature_dir" ]]; then
        log_warn "Feature directory already exists: $feature_dir"
        echo -n "Overwrite? [y/N]: "
        read -r response
        response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
        if [[ "$response" != "y" ]] && [[ "$response" != "yes" ]]; then
            log_info "Restore cancelled"
            return 1
        fi
        rm -rf "$feature_dir"
    fi

    # Create feature directory
    mkdir -p "$feature_dir"

    # Copy files from archive
    cp -r "$source_archive"/* "$feature_dir/" 2>/dev/null || true

    # Restore spec.md and config from git if available
    git checkout HEAD -- "${feature_dir}/spec.md" "${feature_dir}/config.yaml" 2>/dev/null || true
    git checkout HEAD -- ".ralph/config.yaml" 2>/dev/null || true

    log_success "Restored feature from archive"
    log_info "Feature folder: $feature_dir"

    # Show status
    echo ""
    cmd_status

    return 0
}

#=============================================================================
# Verify Command - Run Goal-Backward Verification
#=============================================================================

# Exit codes for verification
readonly VERIFY_EXIT_VERIFIED=0
readonly VERIFY_EXIT_NEEDS_WORK=1
readonly VERIFY_EXIT_BLOCKED=2

# Run goal-backward verification on the current feature
# Uses the verifier.md template with Claude to check:
# - Goals achieved (not just tasks completed)
# - Stub detection
# - Wiring verification
# - Human testing items flagged
cmd_verify() {
    local profile=""
    local model=""
    local output_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile)
                profile="$2"
                shift 2
                ;;
            --model|-m)
                model="$2"
                shift 2
                ;;
            --output|-o)
                output_file="$2"
                shift 2
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            --help|-h)
                _verify_show_help
                return 0
                ;;
            *)
                log_error "Unknown option: $1"
                _verify_show_help
                return 1
                ;;
        esac
    done

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Get feature directory
    local feature_dir
    if ! feature_dir=$(get_feature_dir 2>/dev/null); then
        log_error "Not in a feature branch or feature not initialized"
        log_info "Run 'ralph-hybrid setup' and create a feature using /ralph-hybrid-plan"
        return 1
    fi

    # Check required files exist
    local spec_file="${feature_dir}/spec.md"
    local prd_file="${feature_dir}/prd.json"
    local progress_file="${feature_dir}/progress.txt"

    if [[ ! -f "$spec_file" ]]; then
        log_error "spec.md not found at: $spec_file"
        log_info "Create a spec using /ralph-hybrid-plan first"
        return 1
    fi

    if [[ ! -f "$prd_file" ]]; then
        log_error "prd.json not found at: $prd_file"
        log_info "Create a PRD using /ralph-hybrid-plan first"
        return 1
    fi

    # Set default output file
    if [[ -z "$output_file" ]]; then
        output_file="${feature_dir}/VERIFICATION.md"
    fi

    # Determine model to use
    # Priority: CLI model > profile verification model > default
    local effective_model=""
    if [[ -n "$model" ]]; then
        effective_model="$model"
    elif [[ -n "$profile" ]]; then
        if ! cfg_validate_profile "$profile"; then
            log_error "Invalid profile: $profile"
            log_info "Valid profiles: quality, balanced, budget (or custom from config)"
            return 1
        fi
        effective_model=$(cfg_get_profile_model "$profile" "verification")
    elif [[ -n "${RALPH_HYBRID_PROFILE:-}" ]]; then
        effective_model=$(cfg_get_profile_model "$RALPH_HYBRID_PROFILE" "verification")
    fi

    log_info "Running goal-backward verification..."
    log_info "Feature: $(basename "$feature_dir")"

    # Build the verification prompt
    local prompt
    prompt=$(_verify_build_prompt "$feature_dir" "$spec_file" "$prd_file" "$progress_file")

    # Build Claude command
    local claude_args="--permission-mode bypassPermissions"
    if [[ -n "$effective_model" ]]; then
        claude_args+=" --model ${effective_model}"
        log_debug "Using model: $effective_model"
    fi

    # Run Claude with the verifier prompt
    log_info "Invoking verification agent..."

    local temp_output
    temp_output=$(mktemp)

    set +e
    echo "$prompt" | claude -p $claude_args 2>&1 | tee "$temp_output"
    local claude_exit=$?
    set -e

    if [[ $claude_exit -ne 0 ]]; then
        log_error "Claude verification failed with exit code: $claude_exit"
        rm -f "$temp_output"
        return 1
    fi

    # Extract VERIFICATION.md content from output
    local verification_content
    verification_content=$(_verify_extract_markdown "$temp_output")

    if [[ -z "$verification_content" ]]; then
        log_warn "Could not extract VERIFICATION.md from output"
        log_info "Raw output saved to: $temp_output"
        # Use the full output as verification content
        verification_content=$(cat "$temp_output")
    fi

    # Save verification output
    echo "$verification_content" > "$output_file"
    log_success "Verification saved to: $output_file"
    rm -f "$temp_output"

    # Parse verdict and return appropriate exit code
    local verdict
    verdict=$(_verify_extract_verdict "$output_file")

    # Display summary
    echo ""
    _verify_display_summary "$output_file" "$verdict"

    # Flag human testing items
    local human_items
    human_items=$(_verify_count_human_testing_items "$output_file")
    if [[ $human_items -gt 0 ]]; then
        echo ""
        log_warn "Human testing required: $human_items item(s) need manual verification"
        log_info "See 'Human Testing Required' section in $output_file"
    fi

    # Return exit code based on verdict
    case "$verdict" in
        VERIFIED)
            log_success "Verification complete: VERIFIED"
            return $VERIFY_EXIT_VERIFIED
            ;;
        NEEDS_WORK)
            log_warn "Verification complete: NEEDS_WORK"
            return $VERIFY_EXIT_NEEDS_WORK
            ;;
        BLOCKED)
            log_error "Verification complete: BLOCKED"
            return $VERIFY_EXIT_BLOCKED
            ;;
        *)
            log_warn "Could not determine verdict (defaulting to NEEDS_WORK)"
            return $VERIFY_EXIT_NEEDS_WORK
            ;;
    esac
}

# Show help for verify command
_verify_show_help() {
    cat << EOF
Ralph Hybrid - Verify Command

Usage: ralph-hybrid verify [options]

Run goal-backward verification on the current feature to ensure:
- Goals are actually achieved (not just tasks completed)
- No stub or placeholder code remains
- Components are properly wired together
- Human testing items are flagged

Options:
  --profile PROFILE    Model profile to use (quality, balanced, budget)
  --model, -m MODEL    Specific model to use (overrides profile)
  --output, -o FILE    Output file (default: .ralph-hybrid/{branch}/VERIFICATION.md)
  --verbose, -v        Enable verbose output
  --help, -h           Show this help message

Exit Codes:
  0 - VERIFIED: All goals achieved, no issues found
  1 - NEEDS_WORK: Issues found that need to be fixed
  2 - BLOCKED: Critical issues preventing feature completion

Examples:
  ralph-hybrid verify                    # Run with default settings
  ralph-hybrid verify --profile quality  # Use quality profile (opus model)
  ralph-hybrid verify -m sonnet          # Use specific model
  ralph-hybrid verify -o custom.md       # Custom output file
EOF
}

# Build the verification prompt with feature context
_verify_build_prompt() {
    local feature_dir="$1"
    local spec_file="$2"
    local prd_file="$3"
    local progress_file="$4"

    local template_file="${SCRIPT_DIR}/templates/verifier.md"
    local branch_name
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local timestamp
    timestamp=$(date -Iseconds)
    local feature_name
    feature_name=$(basename "$feature_dir")

    # Start with template
    local prompt=""
    if [[ -f "$template_file" ]]; then
        prompt=$(cat "$template_file")
    else
        log_error "Verifier template not found at: $template_file"
        return 1
    fi

    # Replace placeholders
    prompt="${prompt//\{\{FEATURE_NAME\}\}/$feature_name}"
    prompt="${prompt//\{\{TIMESTAMP\}\}/$timestamp}"
    prompt="${prompt//\{\{BRANCH_NAME\}\}/$branch_name}"

    # Add context files
    prompt+=$'\n\n---\n\n'
    prompt+="# Verification Context"$'\n\n'

    prompt+="## spec.md"$'\n\n'
    prompt+='```markdown'$'\n'
    prompt+=$(cat "$spec_file")
    prompt+=$'\n```\n\n'

    prompt+="## prd.json"$'\n\n'
    prompt+='```json'$'\n'
    prompt+=$(cat "$prd_file")
    prompt+=$'\n```\n\n'

    if [[ -f "$progress_file" ]]; then
        prompt+="## progress.txt"$'\n\n'
        prompt+='```'$'\n'
        prompt+=$(cat "$progress_file")
        prompt+=$'\n```\n\n'
    fi

    prompt+=$'\n---\n\n'
    prompt+="Now perform the goal-backward verification and output a complete VERIFICATION.md file."

    echo "$prompt"
}

# Extract markdown content from Claude output
_verify_extract_markdown() {
    local output_file="$1"

    # Try to extract content between markdown code blocks
    # or content that starts with "# Feature Verification"
    local content
    content=$(cat "$output_file")

    # Look for VERIFICATION.md content markers
    if echo "$content" | grep -q "^# Feature Verification"; then
        # Content starts with the expected header, extract from there
        echo "$content" | sed -n '/^# Feature Verification/,$p'
        return 0
    fi

    # Try extracting from markdown code block
    if echo "$content" | grep -q '```markdown'; then
        echo "$content" | sed -n '/```markdown/,/```/p' | sed '1d;$d'
        return 0
    fi

    # Return empty if no clear markdown found
    echo ""
}

# Extract verdict from verification output
_verify_extract_verdict() {
    local output_file="$1"

    # Look for "**Verdict:** XXXX" pattern
    local verdict
    verdict=$(grep -oE '\*\*Verdict:\*\*\s*(VERIFIED|NEEDS_WORK|BLOCKED)' "$output_file" | head -1 | grep -oE '(VERIFIED|NEEDS_WORK|BLOCKED)' || echo "")

    if [[ -z "$verdict" ]]; then
        # Try alternate patterns
        verdict=$(grep -oE 'Verdict:\s*(VERIFIED|NEEDS_WORK|BLOCKED)' "$output_file" | head -1 | grep -oE '(VERIFIED|NEEDS_WORK|BLOCKED)' || echo "")
    fi

    echo "$verdict"
}

# Display verification summary
_verify_display_summary() {
    local output_file="$1"
    local verdict="$2"

    echo "━━━ Verification Summary ━━━"
    echo ""

    # Extract and display issue counts
    local stub_count wiring_count deliverable_count partial_count human_count

    stub_count=$(grep -c "STUB_FOUND" "$output_file" 2>/dev/null || echo "0")
    wiring_count=$(grep -c "WIRING_MISSING" "$output_file" 2>/dev/null || echo "0")
    deliverable_count=$(grep -c "DELIVERABLE_MISSING" "$output_file" 2>/dev/null || echo "0")
    partial_count=$(grep -c "PARTIAL_IMPLEMENTATION" "$output_file" 2>/dev/null || echo "0")
    human_count=$(_verify_count_human_testing_items "$output_file")

    printf "  %-25s %s\n" "Stubs found:" "$stub_count"
    printf "  %-25s %s\n" "Wiring issues:" "$wiring_count"
    printf "  %-25s %s\n" "Missing deliverables:" "$deliverable_count"
    printf "  %-25s %s\n" "Partial implementations:" "$partial_count"
    printf "  %-25s %s\n" "Human testing items:" "$human_count"
    echo ""

    # Show verdict with color
    case "$verdict" in
        VERIFIED)
            printf "  Verdict: ${UI_SUCCESS}%s${UI_RESET}\n" "$verdict"
            ;;
        NEEDS_WORK)
            printf "  Verdict: ${UI_WARNING}%s${UI_RESET}\n" "$verdict"
            ;;
        BLOCKED)
            printf "  Verdict: ${UI_ERROR}%s${UI_RESET}\n" "$verdict"
            ;;
        *)
            printf "  Verdict: %s\n" "${verdict:-UNKNOWN}"
            ;;
    esac
}

# Count human testing items in verification output
_verify_count_human_testing_items() {
    local output_file="$1"

    # Count checkbox items in Human Testing Required section
    local count=0

    # Extract human testing section and count checkboxes
    # Pattern matches from "Human Testing Required" to next top-level ## section
    if grep -q "Human Testing Required" "$output_file" 2>/dev/null; then
        # grep -c returns 0 (and exit code 1) when no matches, so capture and handle
        count=$(sed -n '/Human Testing Required/,/^## [^#]/p' "$output_file" | grep -c '^\s*- \[' 2>/dev/null) || count=0
    fi

    echo "$count"
}

#=============================================================================
# Integrate Command - Check Feature Integration
#=============================================================================

cmd_integrate() {
    local profile=""
    local model=""
    local output_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile)
                profile="$2"
                shift 2
                ;;
            --model|-m)
                model="$2"
                shift 2
                ;;
            --output|-o)
                output_file="$2"
                shift 2
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            --help|-h)
                _integrate_show_help
                return 0
                ;;
            *)
                log_error "Unknown option: $1"
                _integrate_show_help
                return 1
                ;;
        esac
    done

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Get feature directory
    local feature_dir
    if ! feature_dir=$(get_feature_dir 2>/dev/null); then
        log_error "Not in a feature branch or feature not initialized"
        log_info "Run 'ralph-hybrid setup' and create a feature using /ralph-hybrid-plan"
        return 1
    fi

    # Check required files exist
    local spec_file="${feature_dir}/spec.md"
    local prd_file="${feature_dir}/prd.json"
    local progress_file="${feature_dir}/progress.txt"

    if [[ ! -f "$spec_file" ]]; then
        log_error "spec.md not found at: $spec_file"
        log_info "Create a spec using /ralph-hybrid-plan first"
        return 1
    fi

    if [[ ! -f "$prd_file" ]]; then
        log_error "prd.json not found at: $prd_file"
        log_info "Create a PRD using /ralph-hybrid-plan first"
        return 1
    fi

    # Set default output file
    if [[ -z "$output_file" ]]; then
        output_file="${feature_dir}/INTEGRATION.md"
    fi

    # Determine model to use
    # Priority: CLI model > profile verification model > default
    local effective_model=""
    if [[ -n "$model" ]]; then
        effective_model="$model"
    elif [[ -n "$profile" ]]; then
        if ! cfg_validate_profile "$profile"; then
            log_error "Invalid profile: $profile"
            log_info "Valid profiles: quality, balanced, budget (or custom from config)"
            return 1
        fi
        effective_model=$(cfg_get_profile_model "$profile" "verification")
    elif [[ -n "${RALPH_HYBRID_PROFILE:-}" ]]; then
        effective_model=$(cfg_get_profile_model "$RALPH_HYBRID_PROFILE" "verification")
    fi

    log_info "Running integration check..."
    log_info "Feature: $(basename "$feature_dir")"

    # Build the integration prompt
    local prompt
    prompt=$(_integrate_build_prompt "$feature_dir" "$spec_file" "$prd_file" "$progress_file")

    # Build Claude command
    local claude_args="--permission-mode bypassPermissions"
    if [[ -n "$effective_model" ]]; then
        claude_args+=" --model ${effective_model}"
        log_debug "Using model: $effective_model"
    fi

    # Run Claude with the integration checker prompt
    log_info "Invoking integration checker agent..."

    local temp_output
    temp_output=$(mktemp)

    set +e
    echo "$prompt" | claude -p $claude_args 2>&1 | tee "$temp_output"
    local claude_exit=$?
    set -e

    if [[ $claude_exit -ne 0 ]]; then
        log_error "Claude integration check failed with exit code: $claude_exit"
        rm -f "$temp_output"
        return 1
    fi

    # Extract INTEGRATION.md content from output
    local integration_content
    integration_content=$(_integrate_extract_markdown "$temp_output")

    if [[ -z "$integration_content" ]]; then
        log_warn "Could not extract INTEGRATION.md from output"
        log_info "Raw output saved to: $temp_output"
        # Use the full output as integration content
        integration_content=$(cat "$temp_output")
    fi

    # Save integration output
    echo "$integration_content" > "$output_file"
    log_success "Integration check saved to: $output_file"
    rm -f "$temp_output"

    # Parse verdict and return appropriate exit code
    local verdict
    verdict=$(_integrate_extract_verdict "$output_file")

    # Display summary
    echo ""
    _integrate_display_summary "$output_file" "$verdict"

    # Return exit code based on verdict
    case "$verdict" in
        INTEGRATED)
            log_success "Integration check complete: INTEGRATED"
            return $INTEGRATE_EXIT_INTEGRATED
            ;;
        NEEDS_WIRING)
            log_warn "Integration check complete: NEEDS_WIRING"
            _integrate_display_recommendations "$output_file"
            return $INTEGRATE_EXIT_NEEDS_WIRING
            ;;
        BROKEN)
            log_error "Integration check complete: BROKEN"
            _integrate_display_recommendations "$output_file"
            return $INTEGRATE_EXIT_BROKEN
            ;;
        *)
            log_warn "Could not determine verdict (defaulting to NEEDS_WIRING)"
            return $INTEGRATE_EXIT_NEEDS_WIRING
            ;;
    esac
}

# Show help for integrate command
_integrate_show_help() {
    cat << EOF
Ralph Hybrid - Integrate Command

Usage: ralph-hybrid integrate [options]

Run integration check on the current feature to ensure:
- All exports are imported and used somewhere
- All routes have consumers (frontend calls, CLI commands, etc.)
- Sensitive routes have authentication/authorization
- Data flows completely from input to output without breaks

Options:
  --profile PROFILE    Model profile to use (quality, balanced, budget)
  --model, -m MODEL    Specific model to use (overrides profile)
  --output, -o FILE    Output file (default: .ralph-hybrid/{branch}/INTEGRATION.md)
  --verbose, -v        Enable verbose output
  --help, -h           Show this help message

Exit Codes:
  0 - INTEGRATED: All components connected, no orphaned code
  1 - NEEDS_WIRING: Components exist but connections missing
  2 - BROKEN: Critical integration failures, major components disconnected

Examples:
  ralph-hybrid integrate                    # Run with default settings
  ralph-hybrid integrate --profile quality  # Use quality profile (opus model)
  ralph-hybrid integrate -m sonnet          # Use specific model
  ralph-hybrid integrate -o custom.md       # Custom output file
EOF
}

# Build the integration prompt with feature context
_integrate_build_prompt() {
    local feature_dir="$1"
    local spec_file="$2"
    local prd_file="$3"
    local progress_file="$4"

    local template_file="${SCRIPT_DIR}/templates/integration-checker.md"
    local branch_name
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local timestamp
    timestamp=$(date -Iseconds)
    local feature_name
    feature_name=$(basename "$feature_dir")

    # Start with template
    local prompt=""
    if [[ -f "$template_file" ]]; then
        prompt=$(cat "$template_file")
    else
        log_error "Integration checker template not found at: $template_file"
        return 1
    fi

    # Replace placeholders
    prompt="${prompt//\{\{FEATURE_NAME\}\}/$feature_name}"
    prompt="${prompt//\{\{TIMESTAMP\}\}/$timestamp}"
    prompt="${prompt//\{\{BRANCH_NAME\}\}/$branch_name}"

    # Add context files
    prompt+=$'\n\n---\n\n'
    prompt+="# Integration Check Context"$'\n\n'

    prompt+="## spec.md"$'\n\n'
    prompt+='```markdown'$'\n'
    prompt+=$(cat "$spec_file")
    prompt+=$'\n```\n\n'

    prompt+="## prd.json"$'\n\n'
    prompt+='```json'$'\n'
    prompt+=$(cat "$prd_file")
    prompt+=$'\n```\n\n'

    if [[ -f "$progress_file" ]]; then
        prompt+="## progress.txt"$'\n\n'
        prompt+='```'$'\n'
        prompt+=$(cat "$progress_file")
        prompt+=$'\n```\n\n'
    fi

    prompt+=$'\n---\n\n'
    prompt+="Now perform the integration check and output a complete INTEGRATION.md file."

    echo "$prompt"
}

# Extract markdown content from Claude output
_integrate_extract_markdown() {
    local output_file="$1"

    # Try to extract content between markdown code blocks
    # or content that starts with "# Integration Check"
    local content
    content=$(cat "$output_file")

    # Look for INTEGRATION.md content markers
    if echo "$content" | grep -q "^# Integration Check"; then
        # Content starts with the expected header, extract from there
        echo "$content" | sed -n '/^# Integration Check/,$p'
        return 0
    fi

    # Try extracting from markdown code block
    if echo "$content" | grep -q '```markdown'; then
        echo "$content" | sed -n '/```markdown/,/```/p' | sed '1d;$d'
        return 0
    fi

    # Return empty if no clear markdown found
    echo ""
}

# Extract verdict from integration output
_integrate_extract_verdict() {
    local output_file="$1"

    # Look for "**Verdict:** XXXX" pattern
    local verdict
    verdict=$(grep -oE '\*\*Verdict:\*\*\s*(INTEGRATED|NEEDS_WIRING|BROKEN)' "$output_file" | head -1 | grep -oE '(INTEGRATED|NEEDS_WIRING|BROKEN)' || echo "")

    if [[ -z "$verdict" ]]; then
        # Try alternate patterns
        verdict=$(grep -oE 'Verdict:\s*(INTEGRATED|NEEDS_WIRING|BROKEN)' "$output_file" | head -1 | grep -oE '(INTEGRATED|NEEDS_WIRING|BROKEN)' || echo "")
    fi

    echo "$verdict"
}

# Display integration summary
_integrate_display_summary() {
    local output_file="$1"
    local verdict="$2"

    echo "━━━ Integration Summary ━━━"
    echo ""

    # Extract and display issue counts
    local orphan_export_count orphan_route_count missing_auth_count broken_flow_count dead_code_count missing_conn_count

    orphan_export_count=$(grep -c "ORPHANED_EXPORT\|ORPHAN-[0-9]" "$output_file" 2>/dev/null || echo "0")
    orphan_route_count=$(grep -c "ORPHANED_ROUTE\|ROUTE-[0-9]" "$output_file" 2>/dev/null || echo "0")
    missing_auth_count=$(grep -c "MISSING_AUTH\|AUTH-[0-9]" "$output_file" 2>/dev/null || echo "0")
    broken_flow_count=$(grep -c "BROKEN_FLOW\|FLOW-[0-9]" "$output_file" 2>/dev/null || echo "0")
    dead_code_count=$(grep -c "DEAD_CODE\|DEAD-[0-9]" "$output_file" 2>/dev/null || echo "0")
    missing_conn_count=$(grep -c "MISSING_CONNECTION\|CONN-[0-9]" "$output_file" 2>/dev/null || echo "0")

    printf "  %-25s %s\n" "Orphaned exports:" "$orphan_export_count"
    printf "  %-25s %s\n" "Orphaned routes:" "$orphan_route_count"
    printf "  %-25s %s\n" "Missing auth:" "$missing_auth_count"
    printf "  %-25s %s\n" "Broken flows:" "$broken_flow_count"
    printf "  %-25s %s\n" "Dead code:" "$dead_code_count"
    printf "  %-25s %s\n" "Missing connections:" "$missing_conn_count"
    echo ""

    # Show verdict with color
    case "$verdict" in
        INTEGRATED)
            printf "  Verdict: ${UI_SUCCESS}%s${UI_RESET}\n" "$verdict"
            ;;
        NEEDS_WIRING)
            printf "  Verdict: ${UI_WARNING}%s${UI_RESET}\n" "$verdict"
            ;;
        BROKEN)
            printf "  Verdict: ${UI_ERROR}%s${UI_RESET}\n" "$verdict"
            ;;
        *)
            printf "  Verdict: %s\n" "${verdict:-UNKNOWN}"
            ;;
    esac
}

# Display recommendations from integration output
_integrate_display_recommendations() {
    local output_file="$1"

    # Check if there's a Recommendations section
    if grep -q "## Recommendations" "$output_file" 2>/dev/null; then
        echo ""
        log_info "See 'Recommendations' section in $output_file for fix suggestions"

        # Count critical recommendations
        local critical_count
        critical_count=$(sed -n '/### Critical/,/### /p' "$output_file" | grep -c '^\s*[0-9]*\.' 2>/dev/null) || critical_count=0

        if [[ $critical_count -gt 0 ]]; then
            log_warn "Critical issues requiring immediate fix: $critical_count"
        fi
    fi
}

#=============================================================================
# Debug Command - Scientific Debugging with State Persistence
#=============================================================================

cmd_debug() {
    local profile=""
    local model=""
    local verbose=false
    local do_continue=false
    local do_reset=false
    local problem_description=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile)
                profile="$2"
                shift 2
                ;;
            --model|-m)
                model="$2"
                shift 2
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            --continue)
                do_continue=true
                shift
                ;;
            --reset)
                do_reset=true
                shift
                ;;
            --help|-h)
                _debug_show_help
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                _debug_show_help
                return 1
                ;;
            *)
                # Non-option argument is the problem description
                problem_description="$1"
                shift
                ;;
        esac
    done

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Get feature directory
    local feature_dir
    if ! feature_dir=$(get_feature_dir 2>/dev/null); then
        log_error "Not in a feature branch or feature not initialized"
        log_info "Run 'ralph-hybrid setup' and create a feature using /ralph-hybrid-plan"
        return 1
    fi

    local state_file
    state_file=$(debug_get_state_file "$feature_dir")

    # Handle reset flag
    if [[ "$do_reset" == true ]] && [[ -f "$state_file" ]]; then
        log_warn "Removing existing debug state..."
        rm -f "$state_file"
    fi

    # Check for existing state
    local existing_state=""
    local session_num=1

    if debug_state_exists "$feature_dir"; then
        existing_state=$(debug_load_state "$feature_dir")
        local existing_status
        existing_status=$(debug_extract_status "$existing_state")

        if [[ "$do_continue" != true ]] && [[ "$existing_status" =~ ^(CHECKPOINT_REACHED|IN_PROGRESS)$ ]]; then
            log_info "Existing debug session found (Status: $existing_status)"
            echo ""
            echo "Previous session is in progress. Would you like to:"
            echo "  1) Continue from where you left off"
            echo "  2) Start fresh (discard previous state)"
            echo ""
            local choice
            read -r -p "Choice [1/2]: " choice
            case "$choice" in
                2)
                    existing_state=""
                    rm -f "$state_file"
                    log_info "Starting fresh debug session"
                    ;;
                *)
                    do_continue=true
                    log_info "Continuing previous debug session"
                    ;;
            esac
        elif [[ "$do_continue" == true ]]; then
            log_info "Continuing debug session (Status: $existing_status)"
        fi

        if [[ -n "$existing_state" ]]; then
            session_num=$(debug_get_next_session "$existing_state")
        fi
    fi

    # Require problem description for new sessions
    if [[ -z "$existing_state" ]] && [[ -z "$problem_description" ]]; then
        log_error "Problem description required for new debug session"
        echo ""
        echo "Usage: ralph-hybrid debug \"description of the problem\""
        echo ""
        echo "Example:"
        echo "  ralph-hybrid debug \"tests failing after refactor\""
        echo "  ralph-hybrid debug \"users can't log in after password reset\""
        return 1
    fi

    # Determine model to use
    local effective_model=""
    if [[ -n "$model" ]]; then
        effective_model="$model"
    elif [[ -n "$profile" ]]; then
        if ! cfg_validate_profile "$profile"; then
            log_error "Invalid profile: $profile"
            log_info "Valid profiles: quality, balanced, budget (or custom from config)"
            return 1
        fi
        effective_model=$(cfg_get_profile_model "$profile" "execution")
    elif [[ -n "${RALPH_HYBRID_PROFILE:-}" ]]; then
        effective_model=$(cfg_get_profile_model "$RALPH_HYBRID_PROFILE" "execution")
    fi

    log_info "Starting scientific debug session #${session_num}..."
    log_info "Feature: $(basename "$feature_dir")"

    # Build the debug prompt
    local prompt
    prompt=$(_debug_build_prompt "$feature_dir" "$problem_description" "$existing_state" "$session_num")

    # Build Claude command
    local claude_args="--permission-mode bypassPermissions"
    if [[ -n "$effective_model" ]]; then
        claude_args+=" --model ${effective_model}"
        log_debug "Using model: $effective_model"
    fi

    # Run Claude with the debug prompt
    log_info "Invoking debug agent..."
    if [[ "$verbose" == true ]]; then
        log_debug "Problem: ${problem_description:-'(continuing previous session)'}"
    fi

    local temp_output
    temp_output=$(mktemp)

    set +e
    echo "$prompt" | claude -p $claude_args 2>&1 | tee "$temp_output"
    local claude_exit=$?
    set -e

    if [[ $claude_exit -ne 0 ]]; then
        log_error "Claude debugging failed with exit code: $claude_exit"
        rm -f "$temp_output"
        return 1
    fi

    # Extract and save debug state
    local debug_state
    debug_state=$(debug_extract_state_from_output "$temp_output")

    if [[ -z "$debug_state" ]]; then
        log_warn "Could not extract debug state from output"
        log_info "Raw output saved to: $temp_output"
        debug_state=$(cat "$temp_output")
    fi

    # Save debug state
    debug_save_state "$feature_dir" "$debug_state"
    log_success "Debug state saved to: $state_file"
    rm -f "$temp_output"

    # Parse the debug status
    local status
    status=$(debug_extract_status "$debug_state")

    # Display summary
    echo ""
    _debug_display_summary "$debug_state" "$status"

    # Handle post-debug actions based on status
    case "$status" in
        ROOT_CAUSE_FOUND)
            echo ""
            local action
            action=$(debug_prompt_user_action "$(debug_extract_root_cause "$debug_state")")

            case "$action" in
                fix)
                    log_info "Starting fix implementation..."
                    local fix_prompt
                    fix_prompt=$(debug_build_fix_prompt "$feature_dir" "$debug_state")
                    echo "$fix_prompt" | claude -p $claude_args
                    ;;
                plan)
                    log_info "Creating solution plan..."
                    local plan_prompt
                    plan_prompt=$(debug_build_plan_prompt "$feature_dir" "$debug_state")
                    echo "$plan_prompt" | claude -p $claude_args
                    ;;
                manual)
                    log_info "Exiting for manual handling"
                    log_info "Debug state saved to: $state_file"
                    ;;
            esac
            return $DEBUG_EXIT_ROOT_CAUSE_FOUND
            ;;
        DEBUG_COMPLETE)
            log_success "Debugging complete - issue resolved!"
            return $DEBUG_EXIT_DEBUG_COMPLETE
            ;;
        CHECKPOINT_REACHED)
            log_warn "Debug session reached checkpoint"
            log_info "Run 'ralph-hybrid debug --continue' to continue"
            return $DEBUG_EXIT_CHECKPOINT_REACHED
            ;;
        *)
            log_warn "Debug session ended with status: $status"
            return $DEBUG_EXIT_ERROR
            ;;
    esac
}

# Show help for debug command
_debug_show_help() {
    cat << EOF
Ralph Hybrid - Debug Command

Usage: ralph-hybrid debug [options] "problem description"
       ralph-hybrid debug --continue

Start or continue a scientific debugging session using hypothesis-driven
investigation to find root causes systematically.

Options:
  --profile PROFILE    Model profile to use (quality, balanced, budget)
  --model, -m MODEL    Specific model to use (overrides profile)
  --continue           Continue from previous debug state
  --reset              Start fresh, discarding previous debug state
  --verbose, -v        Enable verbose output
  --help, -h           Show this help message

Exit Codes:
  0  - ROOT_CAUSE_FOUND or DEBUG_COMPLETE
  1  - Error during debugging
  10 - CHECKPOINT_REACHED (needs continuation)

Debug States:
  ROOT_CAUSE_FOUND   - Root cause identified, user chooses next action
  DEBUG_COMPLETE     - Issue fixed and verified
  CHECKPOINT_REACHED - Progress saved, needs continuation

Examples:
  ralph-hybrid debug "tests failing after refactor"
  ralph-hybrid debug --profile quality "users can't log in"
  ralph-hybrid debug --continue
  ralph-hybrid debug --reset "start fresh investigation"
EOF
}

# Build the debug prompt with problem and previous state
_debug_build_prompt() {
    local feature_dir="$1"
    local problem_description="$2"
    local existing_state="$3"
    local session_num="$4"

    local template_file="${SCRIPT_DIR}/templates/debug-agent.md"
    local branch_name
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local timestamp
    timestamp=$(date -Iseconds)

    # Start with template
    local prompt=""
    if [[ -f "$template_file" ]]; then
        prompt=$(cat "$template_file")
    else
        log_error "Debug agent template not found at: $template_file"
        return 1
    fi

    # Add context section
    prompt+=$'\n\n---\n\n'
    prompt+="# Debug Session Context"$'\n\n'
    prompt+="**Session:** ${session_num}"$'\n'
    prompt+="**Branch:** ${branch_name}"$'\n'
    prompt+="**Timestamp:** ${timestamp}"$'\n\n'

    # Add problem description for new sessions
    if [[ -n "$problem_description" ]]; then
        prompt+="## Problem to Debug"$'\n\n'
        prompt+="${problem_description}"$'\n\n'
    fi

    # Add previous state for continuation
    if [[ -n "$existing_state" ]]; then
        prompt+="## Previous Debug State"$'\n\n'
        prompt+="Continue from this state. Do NOT restart from scratch."$'\n\n'
        prompt+='```markdown'$'\n'
        prompt+="${existing_state}"
        prompt+=$'\n```\n\n'

        local current_focus
        current_focus=$(debug_extract_current_focus "$existing_state")
        if [[ -n "$current_focus" ]]; then
            prompt+="**Continue from:** ${current_focus}"$'\n\n'
        fi
    fi

    # Add feature context files if they exist
    local spec_file="${feature_dir}/spec.md"
    local prd_file="${feature_dir}/prd.json"
    local progress_file="${feature_dir}/progress.txt"

    if [[ -f "$spec_file" ]]; then
        prompt+="## Feature Specification (spec.md)"$'\n\n'
        prompt+='```markdown'$'\n'
        prompt+=$(cat "$spec_file")
        prompt+=$'\n```\n\n'
    fi

    if [[ -f "$progress_file" ]]; then
        prompt+="## Recent Progress (progress.txt)"$'\n\n'
        prompt+='```'$'\n'
        prompt+=$(tail -100 "$progress_file")
        prompt+=$'\n```\n\n'
    fi

    prompt+=$'\n---\n\n'
    prompt+="Now begin debugging using the scientific method. "
    if [[ -n "$existing_state" ]]; then
        prompt+="Continue from the previous state - do not restart."
    else
        prompt+="Start by gathering symptoms, then form hypotheses."
    fi
    prompt+=$'\n\n'
    prompt+="Output a complete DEBUG-STATE.md file with your findings."

    echo "$prompt"
}

# Display debug summary
_debug_display_summary() {
    local debug_state="$1"
    local status="$2"

    echo "━━━ Debug Summary ━━━"
    echo ""

    # Extract and display hypothesis counts
    local tested untested
    tested=$(debug_count_tested_hypotheses "$debug_state")
    untested=$(debug_count_untested_hypotheses "$debug_state")

    printf "  %-25s %s\n" "Hypotheses tested:" "$tested"
    printf "  %-25s %s\n" "Hypotheses remaining:" "$untested"

    # Show current focus
    local focus
    focus=$(debug_extract_current_focus "$debug_state")
    if [[ -n "$focus" ]]; then
        printf "  %-25s %s\n" "Current focus:" "$focus"
    fi

    echo ""

    # Show status with color
    case "$status" in
        ROOT_CAUSE_FOUND)
            printf "  Status: ${UI_SUCCESS}%s${UI_RESET}\n" "$status"
            local root_cause
            root_cause=$(debug_extract_root_cause "$debug_state")
            if [[ -n "$root_cause" ]]; then
                echo ""
                echo "  Root Cause:"
                echo "$root_cause" | head -5 | sed 's/^/    /'
            fi
            ;;
        DEBUG_COMPLETE)
            printf "  Status: ${UI_SUCCESS}%s${UI_RESET}\n" "$status"
            ;;
        CHECKPOINT_REACHED)
            printf "  Status: ${UI_WARNING}%s${UI_RESET}\n" "$status"
            ;;
        *)
            printf "  Status: %s\n" "${status:-IN_PROGRESS}"
            ;;
    esac
}

#=============================================================================
# Setup Command - Install Claude Commands to Project
#=============================================================================

# Generate the Ralph Hybrid CLAUDE.md section
_setup_generate_claude_md_section() {
    cat << 'RALPH_SECTION'

---

## Ralph Hybrid (Autonomous Development)

For complex features, use Ralph Hybrid to run autonomous development loops.

### Workflow

```
1. Plan:  /ralph-hybrid-plan "description"   (in Claude Code)
2. Run:   ralph-hybrid run                    (in terminal)
```

### When to Use Ralph

- Multi-story features (3+ related tasks)
- Features derived from GitHub issues
- Work that benefits from TDD iteration
- When you want autonomous implementation with human checkpoints

### Commands

| Command | Where | Purpose |
|---------|-------|---------|
| `/ralph-hybrid-plan` | Claude Code | Interactive planning, creates spec.md + prd.json |
| `/ralph-hybrid-plan --regenerate` | Claude Code | Regenerate prd.json from updated spec.md |
| `/ralph-hybrid-amend` | Claude Code | Modify requirements mid-implementation |
| `ralph-hybrid run` | Terminal | Execute autonomous loop |
| `ralph-hybrid run --monitor` | Terminal | Run with tmux dashboard |
| `ralph-hybrid status` | Terminal | Show feature progress |

### Example: GitHub Issue to Implementation

```bash
# 1. Create branch from issue number
git checkout -b 42-user-authentication

# 2. Plan (Claude auto-fetches issue #42 context)
/ralph-hybrid-plan

# 3. Run autonomous loop
ralph-hybrid run --monitor
```

### Key Concepts

- **Fresh context per iteration**: Each loop iteration starts Claude fresh
- **Memory in files**: prd.json tracks story completion, progress.txt logs history
- **Branch = feature folder**: `.ralph-hybrid/{branch-name}/` holds all state
RALPH_SECTION
}

# Append Ralph section to CLAUDE.md if not already present
#-----------------------------------------------------------------------------
# Setup: Update .gitignore with ralph-hybrid ephemeral files
#-----------------------------------------------------------------------------

_setup_update_gitignore() {
    local project_dir="$1"
    local gitignore="${project_dir}/.gitignore"
    local patterns=(
        ".ralph-hybrid/**/rate_limiter.state"
        ".ralph-hybrid/**/status.json"
    )
    local added=0

    # Create .gitignore if it doesn't exist
    if [[ ! -f "$gitignore" ]]; then
        touch "$gitignore"
    fi

    # Add each pattern if not already present
    for pattern in "${patterns[@]}"; do
        if ! grep -qF "$pattern" "$gitignore" 2>/dev/null; then
            echo "$pattern" >> "$gitignore"
            added=$((added + 1))
        fi
    done

    if [[ $added -gt 0 ]]; then
        log_info "Added ${added} pattern(s) to .gitignore for ephemeral state files"
    fi

    return 0
}

#-----------------------------------------------------------------------------
# Setup: Update CLAUDE.md with Ralph section
#-----------------------------------------------------------------------------

_setup_update_claude_md() {
    local project_dir="$1"
    local claude_md="${project_dir}/CLAUDE.md"
    local marker="## Ralph Hybrid"

    # Check if CLAUDE.md exists
    if [[ ! -f "$claude_md" ]]; then
        # Create new CLAUDE.md with Ralph section
        echo "# Project Instructions" > "$claude_md"
        _setup_generate_claude_md_section >> "$claude_md"
        log_info "Created CLAUDE.md with Ralph Hybrid section"
        return 0
    fi

    # Check if CLAUDE.md is a reference file (starts with @)
    local first_line
    first_line=$(head -1 "$claude_md")
    if [[ "$first_line" =~ ^@(.+\.md)$ ]]; then
        local ref_file="${BASH_REMATCH[1]}"
        local ref_path="${project_dir}/${ref_file}"

        # Check the referenced file instead
        if [[ -f "$ref_path" ]]; then
            if grep -q "$marker" "$ref_path" 2>/dev/null; then
                log_info "${ref_file} already has Ralph Hybrid section (skipped)"
                return 0
            fi
            # Append to referenced file
            _setup_generate_claude_md_section >> "$ref_path"
            log_info "Added Ralph Hybrid section to ${ref_file}"
            return 0
        else
            log_warn "Referenced file ${ref_file} not found"
            log_info "Add Ralph Hybrid section manually to your project instructions"
            return 0
        fi
    fi

    # Check if Ralph section already exists
    if grep -q "$marker" "$claude_md" 2>/dev/null; then
        log_info "CLAUDE.md already has Ralph Hybrid section (skipped)"
        return 0
    fi

    # Append Ralph section
    _setup_generate_claude_md_section >> "$claude_md"
    log_info "Added Ralph Hybrid section to CLAUDE.md"
    return 0
}

#-----------------------------------------------------------------------------
# Setup: Copy hook templates to project
#-----------------------------------------------------------------------------

_setup_copy_hook_templates() {
    local project_dir="$1"
    local ralph_home="${HOME}/.ralph-hybrid"
    local hooks_src="${ralph_home}/templates/hooks"
    local hooks_dest="${project_dir}/.ralph-hybrid/hooks"

    # Check if hook templates exist in ralph home
    if [[ ! -d "$hooks_src" ]]; then
        log_debug "No hook templates found in ${hooks_src}"
        return 0
    fi

    # Create project-wide hooks directory
    mkdir -p "$hooks_dest"

    # Copy hook templates (but don't overwrite existing)
    local copied=0
    local skipped=0
    for hook_file in "${hooks_src}"/*.sh; do
        if [[ -f "$hook_file" ]]; then
            local filename
            filename=$(basename "$hook_file")
            if [[ -f "${hooks_dest}/${filename}" ]]; then
                skipped=$((skipped + 1))
            else
                cp "$hook_file" "${hooks_dest}/${filename}"
                chmod +x "${hooks_dest}/${filename}"
                copied=$((copied + 1))
            fi
        fi
    done

    if [[ $copied -gt 0 ]]; then
        log_info "Installed ${copied} hook template(s) to ${hooks_dest}/"
    fi
    if [[ $skipped -gt 0 ]]; then
        log_debug "Skipped ${skipped} existing hook(s)"
    fi

    return 0
}

#-----------------------------------------------------------------------------
# Setup: Copy skill templates to project
#-----------------------------------------------------------------------------

_setup_copy_skill_templates() {
    local project_dir="$1"
    local ralph_home="${HOME}/.ralph-hybrid"
    local skills_src="${ralph_home}/templates/skills"
    local skills_dest="${project_dir}/.ralph-hybrid/skills"

    # Check if skill templates exist in ralph home
    if [[ ! -d "$skills_src" ]]; then
        log_debug "No skill templates found in ${skills_src}"
        return 0
    fi

    # Check if there are any .md files
    local has_skills=0
    for skill_file in "${skills_src}"/*.md; do
        if [[ -f "$skill_file" ]]; then
            has_skills=1
            break
        fi
    done

    if [[ $has_skills -eq 0 ]]; then
        log_debug "No skill templates (*.md) found in ${skills_src}"
        return 0
    fi

    # Create project-wide skills directory
    mkdir -p "$skills_dest"

    # Copy skill templates (but don't overwrite existing)
    local copied=0
    local skipped=0
    for skill_file in "${skills_src}"/*.md; do
        if [[ -f "$skill_file" ]]; then
            local filename
            filename=$(basename "$skill_file")
            if [[ -f "${skills_dest}/${filename}" ]]; then
                skipped=$((skipped + 1))
            else
                cp "$skill_file" "${skills_dest}/${filename}"
                copied=$((copied + 1))
            fi
        fi
    done

    if [[ $copied -gt 0 ]]; then
        log_info "Installed ${copied} skill template(s) to ${skills_dest}/"
    fi
    if [[ $skipped -gt 0 ]]; then
        log_debug "Skipped ${skipped} existing skill(s)"
    fi

    return 0
}

cmd_setup() {
    local ralph_home="${HOME}/.ralph-hybrid"
    local commands_src="${ralph_home}/commands"
    local project_dir="${PWD}"
    local commands_dest="${project_dir}/.claude/commands"

    # Check if ralph-hybrid is installed
    if [[ ! -d "$ralph_home" ]]; then
        log_error "Ralph Hybrid not installed. Run install.sh first."
        return 1
    fi

    # Check if commands exist in ralph home
    if [[ ! -d "$commands_src" ]]; then
        log_error "Commands not found in ${commands_src}"
        log_info "Re-run install.sh to install command files"
        return 1
    fi

    # Check if we're in a git repo
    if ! git rev-parse --git-dir &>/dev/null; then
        log_warn "Not in a git repository. Continuing anyway..."
    fi

    # Create .claude/commands if needed
    mkdir -p "$commands_dest"

    # Copy command files
    local copied=0
    local updated=0
    for cmd_file in "${commands_src}"/*.md; do
        if [[ -f "$cmd_file" ]]; then
            local filename
            filename=$(basename "$cmd_file")
            if [[ -f "${commands_dest}/${filename}" ]]; then
                updated=$((updated + 1))
            else
                copied=$((copied + 1))
            fi
            cp "$cmd_file" "${commands_dest}/${filename}"
        fi
    done

    if [[ $copied -eq 0 && $updated -eq 0 ]]; then
        log_warn "No command files found to install"
        return 1
    fi

    log_success "Installed Claude commands to ${commands_dest}/"
    if [[ $copied -gt 0 ]]; then
        log_info "  Added: ${copied} command(s)"
    fi
    if [[ $updated -gt 0 ]]; then
        log_info "  Updated: ${updated} command(s)"
    fi

    # Update CLAUDE.md with Ralph section
    _setup_update_claude_md "$project_dir"

    # Update .gitignore with ephemeral state files
    _setup_update_gitignore "$project_dir"

    # Copy hook templates to project
    _setup_copy_hook_templates "$project_dir"

    # Copy skill templates to project
    _setup_copy_skill_templates "$project_dir"

    echo ""
    log_info "Quick start:"
    log_info "  1. git checkout -b feature/your-feature"
    log_info "  2. /ralph-hybrid-plan \"description\"    (in Claude Code)"
    log_info "  3. ralph-hybrid run                     (in terminal)"

    return 0
}

#=============================================================================
# Import Command - Import PRD from External File
#=============================================================================

cmd_import() {
    local input_file=""
    local format=""
    local output_path=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format)
                format="${2:-}"
                if [[ -z "$format" ]]; then
                    log_error "--format requires a value"
                    return 1
                fi
                shift 2
                ;;
            --output|-o)
                output_path="${2:-}"
                if [[ -z "$output_path" ]]; then
                    log_error "--output requires a path"
                    return 1
                fi
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$input_file" ]]; then
                    input_file="$1"
                else
                    log_error "Unexpected argument: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate input file
    if [[ -z "$input_file" ]]; then
        log_error "No input file specified"
        log_info "Usage: ralph-hybrid import <file> [--format FORMAT] [--output PATH]"
        return 1
    fi

    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        return 1
    fi

    # Detect format if not specified
    if [[ -z "$format" ]]; then
        format=$(im_detect_format "$input_file")
        log_info "Detected format: $format"
    fi

    # Validate format
    if [[ "$format" == "$IM_FORMAT_UNKNOWN" ]]; then
        log_error "Unknown file format. Use --format to specify (markdown, json)"
        return 1
    fi

    if [[ "$format" == "$IM_FORMAT_PDF" ]]; then
        log_error "PDF format is not yet supported"
        log_info "Consider converting your PDF to Markdown or JSON first."
        return 1
    fi

    # Determine output path
    if [[ -z "$output_path" ]]; then
        # Check git repo first
        if ! check_git_repo; then
            log_error "Not in a git repository. Use --output to specify output path."
            return 1
        fi

        # Get feature directory from current git branch
        local feature_dir
        feature_dir=$(get_feature_dir) || return 1

        # Create feature directory if it doesn't exist
        if [[ ! -d "$feature_dir" ]]; then
            mkdir -p "$feature_dir"
            log_info "Created feature directory: $feature_dir"
        fi

        output_path="${feature_dir}/prd.json"
    fi

    # Convert to PRD format
    log_info "Importing from: $input_file"
    local prd_json
    if ! prd_json=$(im_convert_to_prd "$input_file" "$format"); then
        log_error "Failed to convert file to PRD format"
        return 1
    fi

    # Validate the imported content
    if ! im_validate_prd "$prd_json"; then
        log_warn "Validation found issues. Attempting to fix common problems..."
        prd_json=$(im_fix_common_issues "$prd_json")

        # Re-validate
        if ! im_validate_prd "$prd_json"; then
            log_error "Could not fix all validation issues"
            return 1
        fi
        log_success "Issues fixed successfully"
    fi

    # Ensure output directory exists
    local output_dir
    output_dir=$(dirname "$output_path")
    if [[ ! -d "$output_dir" ]]; then
        mkdir -p "$output_dir"
    fi

    # Write output file
    echo "$prd_json" | deps_jq '.' > "$output_path"
    log_success "Imported PRD to: $output_path"

    # Show summary
    local story_count
    story_count=$(echo "$prd_json" | deps_jq '.userStories | length')
    log_info "Stories imported: $story_count"

    # Check if progress.txt exists, create if needed
    local feature_dir
    feature_dir=$(dirname "$output_path")
    if [[ ! -f "${feature_dir}/progress.txt" ]]; then
        # Create progress.txt
        local feature_name
        feature_name=$(basename "$feature_dir")
        cat > "${feature_dir}/progress.txt" <<EOF
# Progress Log: ${feature_name}
# Started: $(get_timestamp)
# Imported from: $(basename "$input_file")

---
EOF
        log_info "Created progress.txt"
    fi

    # Create spec.md stub if it doesn't exist
    if [[ ! -f "${feature_dir}/spec.md" ]]; then
        local description
        description=$(echo "$prd_json" | deps_jq -r '.description')
        cat > "${feature_dir}/spec.md" <<EOF
---
created: $(get_timestamp)
---

# Imported Feature

## Problem Statement

$description

## Success Criteria

- [ ] All stories complete
- [ ] Tests pass

## User Stories

$(echo "$prd_json" | deps_jq -r '.userStories[] | "### \(.id): \(.title)\n\n\(.description)\n\n**Acceptance Criteria:**\n" + ([.acceptanceCriteria[] | "- [ ] \(.)"] | join("\n")) + "\n"')

## Out of Scope

- TBD

EOF
        log_info "Created spec.md stub"
    fi

    return 0
}

#=============================================================================
# Run Command - Argument Parsing
#=============================================================================

parse_run_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--max-iterations)
                RALPH_HYBRID_MAX_ITERATIONS="${2:-}"
                shift 2
                ;;
            -t|--timeout)
                RALPH_HYBRID_TIMEOUT_MINUTES="${2:-}"
                shift 2
                ;;
            -r|--rate-limit)
                RALPH_HYBRID_RATE_LIMIT="${2:-}"
                shift 2
                ;;
            -p|--prompt)
                RALPH_HYBRID_PROMPT_FILE="${2:-}"
                shift 2
                ;;
            -v|--verbose)
                RALPH_HYBRID_VERBOSE=true
                export RALPH_HYBRID_DEBUG=1
                shift
                ;;
            --no-archive)
                RALPH_HYBRID_NO_ARCHIVE=true
                shift
                ;;
            --dry-run)
                RALPH_HYBRID_DRY_RUN=true
                shift
                ;;
            --skip-preflight)
                RALPH_HYBRID_SKIP_PREFLIGHT=true
                shift
                ;;
            --dangerously-skip-permissions)
                RALPH_HYBRID_DANGEROUSLY_SKIP_PERMISSIONS=true
                shift
                ;;
            --monitor)
                RALPH_HYBRID_MONITOR=true
                shift
                ;;
            -m|--model)
                RALPH_HYBRID_MODEL="${2:-}"
                shift 2
                ;;
            --profile)
                RALPH_HYBRID_PROFILE="${2:-}"
                if [[ -z "$RALPH_HYBRID_PROFILE" ]]; then
                    log_error "Profile name required for --profile"
                    return 1
                fi
                # Validate profile name (built-in or custom in config)
                if ! cfg_validate_profile "$RALPH_HYBRID_PROFILE"; then
                    log_error "Invalid profile: $RALPH_HYBRID_PROFILE (valid: quality, balanced, budget, or custom profiles in config)"
                    return 1
                fi
                export RALPH_HYBRID_PROFILE
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                # No positional arguments expected
                log_error "Unknown argument: $1"
                return 1
                ;;
        esac
    done

    return 0
}

#=============================================================================
# Run Command - Private Helper: Argument Validation
#=============================================================================

# Validate arguments and run preflight checks
# Returns: 0 on success, 1 on failure
_run_validate_args() {
    # Parse arguments
    parse_run_args "$@" || return 1

    # Run preflight checks (unless skipped)
    if [[ "$RALPH_HYBRID_SKIP_PREFLIGHT" == true ]]; then
        log_warn "Skipping preflight validation (--skip-preflight). Use with caution."
    else
        # Check git repo first (required for preflight)
        if ! check_git_repo; then
            return 1
        fi

        # Run all preflight checks
        if ! pf_run_all_checks; then
            return 1
        fi
    fi

    return 0
}

#=============================================================================
# Run Command - Build Prompt
#=============================================================================

build_prompt() {
    local feature_dir="$1"
    local prompt_file="${2:-}"
    local iteration_number="${3:-1}"

    # Get current timestamp for progress.txt entries
    local current_timestamp
    current_timestamp=$(get_timestamp)

    local prd_file="${feature_dir}/prd.json"
    local progress_file="${feature_dir}/progress.txt"
    local specs_dir="${feature_dir}/specs"
    local default_prompt="${feature_dir}/prompt.md"
    local last_error_file="${feature_dir}/last_error.txt"

    # Determine which prompt to use
    local prompt_path
    if [[ -n "$prompt_file" ]] && [[ -f "$prompt_file" ]]; then
        prompt_path="$prompt_file"
    elif [[ -f "$default_prompt" ]]; then
        prompt_path="$default_prompt"
    else
        prompt_path="${SCRIPT_DIR}/templates/prompt-tdd.md"
    fi

    # Build the combined prompt with inline file contents
    # Note: @ file references don't work with claude -p mode, so we inline everything
    cat << EOF
# CONTEXT - READ THIS FIRST

**Working Directory:** \`$(pwd)\`
**Iteration:** ${iteration_number}
**Timestamp:** ${current_timestamp}

**What's Already Done:**
- Project structure exists (check with \`ls\` if needed, but only once)
- Configuration files in place
- \`.ralph-hybrid/\` contains Ralph Hybrid state files (DO NOT MODIFY)

**Your Job:** Implement the next incomplete story from prd.json below.

**Be Efficient:**
- Don't explore unnecessarily
- Don't read files that aren't relevant to the story
- Focus on: read story → implement → commit → done
- Ralph Hybrid handles quality checks automatically

---

$(cat "$prompt_path")

---

## prd.json

\`\`\`json
$(cat "$prd_file")
\`\`\`

---

## progress.txt

\`\`\`
$(cat "$progress_file")
\`\`\`

---

## specs/

$(
    if [[ -d "$specs_dir" ]]; then
        for spec_file in "$specs_dir"/*; do
            if [[ -f "$spec_file" ]]; then
                local fname
                fname=$(basename "$spec_file")
                echo "### $fname"
                echo ""
                echo '```'
                cat "$spec_file"
                echo '```'
                echo ""
            fi
        done
    else
        echo "(no specs directory)"
    fi
)

---

$(
    # Include memories from previous sessions (if auto injection is enabled)
    memory_get_for_iteration "$feature_dir" ""
)

$(
    # Include last error feedback if it exists
    if [[ -f "$last_error_file" ]]; then
        echo "## ⚠️ PREVIOUS ATTEMPT FAILED - YOU MUST FIX THESE ERRORS"
        echo ""
        echo "The previous iteration failed with the following errors:"
        echo ""
        echo '```'
        cat "$last_error_file"
        echo '```'
        echo ""
        echo "**CRITICAL**: You MUST fix all these errors before marking the story complete."
        echo "Review the error output carefully and adjust your implementation."
        echo ""
    fi
)
EOF
}

#=============================================================================
# Run Command - Title Bar Display
#=============================================================================

# Get terminal width (with fallback)
_get_terminal_width() {
    local width
    width=$(tput cols 2>/dev/null || echo 80)
    echo "$width"
}

# Generate a progress bar
# Args: current total width
# Output: [████████░░░░░░░░░░░░] 40%
_progress_bar() {
    local current="$1"
    local total="$2"
    local width="${3:-20}"

    if [[ "$total" -eq 0 ]]; then
        printf '[%s] 0%%' "$(printf '░%.0s' $(seq 1 $width))"
        return
    fi

    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))

    local bar=""
    for ((i=0; i<filled; i++)); do bar+="█"; done
    for ((i=0; i<empty; i++)); do bar+="░"; done

    printf '[%s] %d%%' "$bar" "$percent"
}

# Display the title bar with feature and story context
# Args: feature_name prd_file iteration max_iterations [start_time] [timeout_minutes]
# Sets global: _TITLE_BAR_TIMER_ROW (row where timer should be updated)
_display_title_bar() {
    local feature_name="$1"
    local prd_file="$2"
    local iteration="$3"
    local max_iterations="$4"
    local start_time="${5:-}"
    local timeout_minutes="${6:-${RALPH_HYBRID_TIMEOUT_MINUTES:-15}}"

    local term_width
    term_width=$(_get_terminal_width)
    local bar_width=$((term_width - 4))

    # Calculate timeout countdown if start_time provided
    local timeout_display=""
    if [[ -n "$start_time" ]]; then
        local now elapsed remaining_secs remaining_mins remaining_secs_part
        now=$(date +%s)
        elapsed=$((now - start_time))
        # Use awk for floating point support (fractional minutes like 0.083)
        remaining_secs=$(awk -v tm="$timeout_minutes" -v el="$elapsed" 'BEGIN { r=int(tm*60-el); print (r<0)?0:r }')
        remaining_mins=$((remaining_secs / 60))
        remaining_secs_part=$((remaining_secs % 60))
        timeout_display=$(printf "⏱ %02d:%02d" "$remaining_mins" "$remaining_secs_part")
    fi

    # Get story info
    local total_stories passed_stories current_idx current_title current_id
    total_stories=$(get_prd_total_stories "$prd_file")
    passed_stories=$(get_prd_passes_count "$prd_file")
    current_idx=$(prd_get_current_story_index "$prd_file")
    current_title=$(prd_get_current_story_title "$prd_file")
    current_id=$(prd_get_current_story_id "$prd_file")

    # Truncate title if too long (account for timeout display)
    local timeout_len=${#timeout_display}
    local max_title_len=$((term_width - 40 - timeout_len))
    if [[ ${#current_title} -gt $max_title_len ]]; then
        current_title="${current_title:0:$((max_title_len - 3))}..."
    fi

    # Generate progress bar
    local progress
    progress=$(_progress_bar "$passed_stories" "$total_stories" 20)

    # Box drawing characters
    local h_line="" # horizontal line
    for ((i=0; i<bar_width; i++)); do h_line+="─"; done

    # Clear and draw title bar
    echo ""
    printf "${UI_BORDER}┌%s┐${UI_RESET}\n" "$h_line"

    # Line 1: Feature name
    local line1="  RALPH: ${feature_name}"
    local line1_len=${#line1}
    local padding1=$((bar_width - line1_len))
    printf "${UI_BORDER}│${UI_RESET}${UI_TITLE}%s%*s${UI_RESET}${UI_BORDER}│${UI_RESET}\n" "$line1" "$padding1" ""

    # Line 2: Current story with timeout countdown
    local line2
    if [[ "$current_idx" -gt 0 ]]; then
        line2="  Story ${current_idx}/${total_stories}: ${current_id} - ${current_title}"
    else
        line2="  All stories complete!"
    fi
    local line2_len=${#line2}
    local timeout_len=${#timeout_display}
    local gap2=$((bar_width - line2_len - timeout_len - 2))
    if [[ $gap2 -lt 0 ]]; then gap2=2; fi

    if [[ -n "$timeout_display" ]]; then
        # Print spaces as placeholder for timer - the background timer process will fill in the actual value
        # This avoids duplicate timers (one static from here, one updating from background)
        local timer_placeholder
        # Account for wide emoji: ⏱ is 2 display columns, so add 1 extra space
        timer_placeholder=$(printf "%*s" "$((timeout_len + 1))" "")
        printf "${UI_BORDER}│${UI_RESET}${UI_SUBTITLE}%s${UI_RESET}%*s${UI_MUTED}%s${UI_RESET}  ${UI_BORDER}│${UI_RESET}\n" "$line2" "$gap2" "" "$timer_placeholder"
    else
        local padding2=$((bar_width - line2_len))
        printf "${UI_BORDER}│${UI_RESET}${UI_SUBTITLE}%s%*s${UI_RESET}${UI_BORDER}│${UI_RESET}\n" "$line2" "$padding2" ""
    fi

    # Line 3: Progress bar and iteration
    local iter_info="Iteration ${iteration}/${max_iterations}"
    local line3="  ${progress}  ${passed_stories}/${total_stories} passed"
    local line3_len=${#line3}
    local iter_len=${#iter_info}
    local gap=$((bar_width - line3_len - iter_len - 2))
    if [[ $gap -lt 0 ]]; then gap=2; fi

    printf "${UI_BORDER}│${UI_RESET}${UI_PROGRESS}%s${UI_RESET}%*s${UI_MUTED}%s${UI_RESET}  ${UI_BORDER}│${UI_RESET}\n" "$line3" "$gap" "" "$iter_info"

    printf "${UI_BORDER}└%s┘${UI_RESET}\n" "$h_line"
    echo ""
}

# Global to track the countdown timer background process
_COUNTDOWN_TIMER_PID=""

# Global to track the claude process PID
_CLAUDE_PROCESS_PID=""

# Get current cursor row position
# Output: row number (1-based)
_get_cursor_row() {
    local row=1
    # Request cursor position and read response
    # Response format: ESC[row;colR
    # Requires both stdin to be a terminal AND /dev/tty to be available
    if [[ -t 0 ]] && [[ -r /dev/tty ]] && [[ -w /dev/tty ]]; then
        local oldstty
        oldstty=$(stty -g 2>/dev/null) || true
        stty raw -echo min 0 2>/dev/null || true
        printf '\e[6n' > /dev/tty 2>/dev/null
        local response=""
        # Read until 'R' character
        while IFS= read -rsn1 char; do
            response+="$char"
            [[ "$char" == "R" ]] && break
        done < /dev/tty 2>/dev/null
        stty "$oldstty" 2>/dev/null || true
        # Parse response: ESC[row;colR
        if [[ "$response" =~ \[([0-9]+)\;([0-9]+)R ]]; then
            row="${BASH_REMATCH[1]}"
        fi
    fi
    echo "$row"
}

# Update the countdown timer in the title bar
# Args: timer_row start_time timeout_minutes term_width
# This function updates just the timer portion using cursor positioning
_update_countdown_timer() {
    local timer_row="$1"
    local start_time="$2"
    local timeout_minutes="$3"
    local term_width="$4"

    local now elapsed remaining_secs remaining_mins remaining_secs_part
    now=$(date +%s)
    elapsed=$((now - start_time))
    # Use awk for floating point support (fractional minutes like 0.083)
    remaining_secs=$(awk -v tm="$timeout_minutes" -v el="$elapsed" 'BEGIN { r=int(tm*60-el); print (r<0)?0:r }')
    remaining_mins=$((remaining_secs / 60))
    remaining_secs_part=$((remaining_secs % 60))
    local timeout_display
    timeout_display=$(printf "⏱ %02d:%02d" "$remaining_mins" "$remaining_secs_part")

    # Calculate column position (timer is right-aligned with 2 char padding before border)
    # Account for wide emoji: ⏱ displays as 2 columns but counts as 1 character, so subtract extra 1
    local timer_col=$((term_width - ${#timeout_display} - 3))

    # Save cursor, move to timer position, print timer, restore cursor
    # Write directly to /dev/tty to bypass stdout piping (scrolling window and tee)
    # Use subshell to capture shell redirection errors (not just printf stderr)
    ( printf '\e7\e[%d;%dH%s\e8' "$timer_row" "$timer_col" "$timeout_display" > /dev/tty ) 2>/dev/null || true
}

# Start the countdown timer updater in background
# Args: timer_row start_time timeout_minutes term_width
# Sets: _COUNTDOWN_TIMER_PID
_start_countdown_timer() {
    local timer_row="$1"
    local start_time="$2"
    local timeout_minutes="$3"
    local term_width="$4"

    # Test if /dev/tty is actually usable (not just "writable" per -w check)
    # This catches "Device not configured" errors in non-interactive contexts
    if ! ( printf '' > /dev/tty ) 2>/dev/null; then
        return 0  # Skip timer in non-TTY environments
    fi

    # Run timer update loop in background
    (
        while true; do
            _update_countdown_timer "$timer_row" "$start_time" "$timeout_minutes" "$term_width"
            sleep 1
        done
    ) &
    _COUNTDOWN_TIMER_PID=$!
}

# Stop the countdown timer updater
_stop_countdown_timer() {
    if [[ -n "${_COUNTDOWN_TIMER_PID:-}" ]]; then
        kill "$_COUNTDOWN_TIMER_PID" 2>/dev/null || true
        wait "$_COUNTDOWN_TIMER_PID" 2>/dev/null || true
        _COUNTDOWN_TIMER_PID=""
    fi
}

#=============================================================================
# Run Command - Validation and Setup
#=============================================================================

# Validate prerequisites, git repo, and get feature from branch
# Sets: RUN_FEATURE_NAME, RUN_FEATURE_DIR, RUN_PRD_FILE
# Returns: 0 on success, 1 on failure
run_validate_setup() {
    # Check prerequisites
    if ! check_prerequisites; then
        return 1
    fi

    # Check git repo
    if ! check_git_repo; then
        return 1
    fi

    # Load configuration
    load_config

    # Reload theme with config-specified theme
    theme_load

    # Override config with CLI args (already done via parse_run_args)
    export RALPH_HYBRID_RATE_LIMIT

    # Get feature directory from current git branch
    RUN_FEATURE_DIR=$(get_feature_dir) || return 1
    RUN_FEATURE_NAME=$(basename "$RUN_FEATURE_DIR")
    RUN_PRD_FILE="${RUN_FEATURE_DIR}/prd.json"

    # Verify prd.json exists
    if [[ ! -f "$RUN_PRD_FILE" ]]; then
        log_error "prd.json not found: ${RUN_PRD_FILE}"
        return 1
    fi

    # Verify custom prompt file if specified
    if [[ -n "$RALPH_HYBRID_PROMPT_FILE" ]] && [[ ! -f "$RALPH_HYBRID_PROMPT_FILE" ]]; then
        log_error "Prompt file not found: ${RALPH_HYBRID_PROMPT_FILE}"
        return 1
    fi

    # Set up state directory for this feature
    export RALPH_HYBRID_STATE_DIR="${RUN_FEATURE_DIR}"

    # Set up hooks directory
    export RALPH_HYBRID_HOOKS_DIR="${RUN_FEATURE_DIR}/${RALPH_HYBRID_HOOKS_DIR_NAME}"
    export RALPH_HYBRID_FEATURE_DIR="${RUN_FEATURE_DIR}"
    export RALPH_HYBRID_PRD_FILE="${RUN_PRD_FILE}"

    # Load custom completion patterns from config
    if [[ -n "${RALPH_HYBRID_CUSTOM_COMPLETION_PATTERNS:-}" ]]; then
        IFS=',' read -ra patterns <<< "$RALPH_HYBRID_CUSTOM_COMPLETION_PATTERNS"
        for pattern in "${patterns[@]}"; do
            pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -n "$pattern" ]] && hk_add_completion_pattern "$pattern"
        done
    fi

    return 0
}

#=============================================================================
# Run Command - Dry Run Display
#=============================================================================

# Display dry run information without executing
run_show_dry_run() {
    local feature_name="$1"
    local feature_dir="$2"

    echo "=========================================="
    echo "DRY RUN - Would execute the following:"
    echo "=========================================="
    echo "Feature: ${feature_name}"
    echo "Max iterations: ${RALPH_HYBRID_MAX_ITERATIONS}"
    echo "Timeout: ${RALPH_HYBRID_TIMEOUT_MINUTES} minutes"
    echo "Rate limit: ${RALPH_HYBRID_RATE_LIMIT}/hour"
    echo "Auto-archive: $([ "$RALPH_HYBRID_NO_ARCHIVE" = true ] && echo "no" || echo "yes")"
    echo "Skip permissions: ${RALPH_HYBRID_DANGEROUSLY_SKIP_PERMISSIONS}"
    echo ""
    echo "Prompt preview:"
    echo "---"
    build_prompt "$feature_dir" "$RALPH_HYBRID_PROMPT_FILE" | head -"$_RALPH_HYBRID_DRY_RUN_PREVIEW_LINES"
    echo "..."
    echo "---"
}

#=============================================================================
# Run Command - State Initialization
#=============================================================================

# Initialize circuit breaker and rate limiter
# Returns: 0 on success
run_initialize_state() {
    # Always reset circuit breaker at the start of a fresh run
    # A tripped circuit breaker from a previous session should not block new runs
    cb_reset

    # Initialize rate limiter (preserves state across runs for rate limiting)
    rl_load_state

    return 0
}

#=============================================================================
# Run Command - Private Helper: State Setup
#=============================================================================

# Set up state directory and initialization
# Combines validation, setup, and initialization
# Sets: RUN_FEATURE_NAME, RUN_FEATURE_DIR, RUN_PRD_FILE
# Returns: 0 on success, 1 on failure
_run_setup_state() {
    # Validate and setup (sets RUN_FEATURE_NAME, RUN_FEATURE_DIR, RUN_PRD_FILE)
    run_validate_setup || return 1

    # Initialize state (circuit breaker, rate limiter)
    run_initialize_state "$RUN_PRD_FILE"

    return 0
}

#=============================================================================
# Run Command - Private Helper: Claude Invocation
#=============================================================================

# Invoke Claude CLI with prompt and stream output
# Arguments: prompt_content timeout_cmd log_file iteration
# Returns: exit_code via INVOKE_EXIT_CODE global, output via log_file
_run_invoke_claude() {
    local prompt_content="$1"
    local timeout_cmd="$2"
    local log_file="$3"
    local iteration="$4"

    # Build claude command args
    # Note: --permission-mode bypassPermissions works with -p mode
    # while --dangerously-skip-permissions causes hangs
    local claude_args="--permission-mode bypassPermissions"

    # Get per-story configuration from prd.json (if available)
    local story_model=""
    local story_mcp_servers=""

    if [[ -f "$RUN_PRD_FILE" ]]; then
        story_model=$(prd_get_current_story_model "$RUN_PRD_FILE")
        story_mcp_servers=$(prd_get_current_story_mcp_servers "$RUN_PRD_FILE")
    fi

    # Model selection priority:
    # 1. Story-level model (from prd.json story.model field)
    # 2. CLI --model flag
    # 3. Profile's execution model (from --profile or config)
    # 4. None (let Claude CLI use its default)
    local effective_model=""
    if [[ -n "$story_model" ]]; then
        effective_model="$story_model"
        log_debug "Using story-level model: $story_model"
    elif [[ -n "${RALPH_HYBRID_MODEL:-}" ]]; then
        effective_model="$RALPH_HYBRID_MODEL"
        log_debug "Using CLI model: $RALPH_HYBRID_MODEL"
    elif [[ -n "${RALPH_HYBRID_PROFILE:-}" ]]; then
        effective_model=$(cfg_get_profile_model "$RALPH_HYBRID_PROFILE" "execution")
        if [[ -n "$effective_model" ]]; then
            log_debug "Using profile '$RALPH_HYBRID_PROFILE' execution model: $effective_model"
        fi
    fi

    if [[ -n "$effective_model" ]]; then
        claude_args+=" --model ${effective_model}"
    fi

    # MCP: if story specifies servers, use strict mode with only those servers
    # Three modes:
    #   - No mcpServers field: use global MCP config (no --strict-mcp-config)
    #   - mcpServers: []: explicitly no MCP (--strict-mcp-config with empty config)
    #   - mcpServers: ["x"]: only specified servers (--strict-mcp-config with config)
    if [[ -n "$story_mcp_servers" ]] && [[ "$story_mcp_servers" != "null" ]]; then
        local mcp_config
        if mcp_config=$(mcp_build_config "$story_mcp_servers"); then
            # Note: mcp_config is compact JSON (no spaces), so no quoting needed
            # when word-splitting $claude_args - quotes would be literal characters
            claude_args+=" --strict-mcp-config --mcp-config ${mcp_config}"
            if [[ "$story_mcp_servers" != "[]" ]]; then
                log_debug "Using story-level MCP servers: $story_mcp_servers"
            else
                log_debug "Story explicitly disables MCP servers"
            fi
        else
            log_error "Failed to build MCP config for story - check that servers are configured"
            INVOKE_EXIT_CODE=1
            return 1
        fi
    fi

    # Run Claude with timeout and real-time output
    # Display activity header
    printf "${UI_MUTED}${UI_BORDER}━━━ Claude Activity ━━━${UI_RESET}\n"

    # Initialize log file
    echo "=== Iteration ${iteration} ===" > "$log_file"
    echo "Timestamp: $(get_timestamp)" >> "$log_file"
    echo "" >> "$log_file"

    set +e
    # Use stream-json for real-time visibility, tee to log file
    # Parse JSON stream to show activity while also saving raw output
    # Run in background to allow proper signal handling
    # NOTE: set -f disables glob expansion to prevent {} and [] in MCP JSON
    # from being interpreted as brace/glob patterns
    (
        set -f  # Disable glob expansion for MCP JSON
        echo "$prompt_content" | $timeout_cmd "${RALPH_HYBRID_TIMEOUT_MINUTES}m" \
            claude -p $claude_args --output-format stream-json --verbose 2>&1 | \
            tee -a "$log_file"
        set +f  # Re-enable glob expansion
    ) | \
        {
            # Scrolling window - keep last N lines visible
            declare -a buffer=()
            local window_size=$_RALPH_HYBRID_SCROLLING_WINDOW_SIZE
            local line_count=0
            local tool_count=0
            local start_time=$(date +%s)

            # Hide cursor during updates
            printf '\e[?25l'

            # Print empty lines to create window space
            for ((i=0; i<window_size; i++)); do echo ""; done

            # Track if we've checked MCP status (only check once on init message)
            local mcp_checked=false

            while IFS= read -r line; do
                # Check for MCP server failures (only on first init message)
                if [[ "$mcp_checked" == false ]]; then
                    local failed_mcps
                    if failed_mcps=$(ed_check_mcp_failures "$line"); then
                        # Show warning outside the scrolling window
                        printf '\e[?25h'  # Show cursor temporarily
                        log_warn "MCP server(s) failed to start:"
                        echo "$failed_mcps" | while IFS= read -r server; do
                            log_warn "  - $server"
                        done
                        printf '\e[?25l'  # Hide cursor again
                    fi
                    # Mark as checked if this was an init message (has mcp_servers field)
                    if echo "$line" | jq -e '.mcp_servers' &>/dev/null 2>&1; then
                        mcp_checked=true
                    fi
                fi

                # Parse JSON and extract display text
                local display=""
                local line_color=""
                if echo "$line" | jq -e '.message.content' &>/dev/null; then
                    display=$(echo "$line" | jq -r "
                        .message.content[]? |
                        if .type == \"text\" then
                            \"${UI_TEXT}  text: \" + (.text | split(\"\n\")[0] | .[0:$_RALPH_HYBRID_TEXT_TRUNCATE]) + \"${UI_RESET}\"
                        elif .type == \"tool_use\" then
                            \"${UI_TOOL}  tool: ${UI_TOOL_NAME}\" + .name + \"${UI_RESET}${UI_MUTED}: \" + (.input | tostring | .[0:$_RALPH_HYBRID_TOOL_OUTPUT_TRUNCATE]) + \"${UI_RESET}\"
                        else empty end
                    " 2>/dev/null)
                    if echo "$line" | jq -e '.message.content[]? | select(.type == "tool_use")' &>/dev/null; then
                        tool_count=$((tool_count + 1))
                    fi
                elif echo "$line" | jq -e '.type == "result"' &>/dev/null; then
                    display=$(echo "$line" | jq -r "\"${UI_SUCCESS}  Done: \" + (.result | .[0:70]) + \"${UI_RESET}\"" 2>/dev/null)
                fi

                # Add to buffer if we have display text
                if [[ -n "$display" ]]; then
                    while IFS= read -r dline; do
                        [[ -n "$dline" ]] && buffer+=("$dline")
                    done <<< "$display"

                    # Keep only last window_size lines
                    while [[ ${#buffer[@]} -gt $window_size ]]; do
                        buffer=("${buffer[@]:1}")
                    done

                    # Calculate elapsed and remaining time
                    local now_secs=$(date +%s)
                    local elapsed=$(( now_secs - start_time ))
                    local elapsed_str=$(printf "%02d:%02d" $((elapsed/60)) $((elapsed%60)))
                    # Use awk for floating point support (fractional minutes like 0.083)
                    local timeout_secs=$(awk -v tm="${RALPH_HYBRID_TIMEOUT_MINUTES:-15}" 'BEGIN { print int(tm*60) }')
                    local remaining=$((timeout_secs - elapsed))
                    [[ $remaining -lt 0 ]] && remaining=0
                    local remaining_str=$(printf "%02d:%02d" $((remaining/60)) $((remaining%60)))

                    # Move cursor up and redraw window
                    printf '\e[%dA' "$((window_size + 1))"  # Move up (extra line for header)
                    printf '\e[J'                    # Clear to end of screen

                    # Print status header with elapsed and remaining time
                    printf "${UI_MUTED}${UI_BORDER}━━━ Claude Activity ━━━ ${UI_TEXT}Tools: %d | Elapsed: %s | Remaining: %s${UI_RESET}\n" "$tool_count" "$elapsed_str" "$remaining_str"

                    # Print buffer with padding
                    for ((i=0; i<window_size; i++)); do
                        if [[ $i -lt ${#buffer[@]} ]]; then
                            printf '%b\n' "${buffer[$i]}"
                        else
                            echo ""
                        fi
                    done
                fi
            done

            # Show cursor again
            printf '\e[?25h'
        }
    INVOKE_EXIT_CODE=${PIPESTATUS[1]}
    set -e

    echo "Exit code: ${INVOKE_EXIT_CODE}" >> "$log_file"

    # Apply log filtering if verbosity is not full
    local log_verbosity="${RALPH_HYBRID_LOG_VERBOSITY:-full}"
    if [[ "$log_verbosity" != "full" ]]; then
        local temp_log="${log_file}.tmp"
        lf_filter_stream "$log_verbosity" < "$log_file" > "$temp_log"
        mv "$temp_log" "$log_file"
        log_debug "Log filtered with verbosity: $log_verbosity"
    fi

    log_info "Output saved to: ${log_file}"

    # Record API call
    rl_record_call

    return 0
}

#=============================================================================
# Run Command - Private Helper: Completion Handling
#=============================================================================

# Archive feature with deferred work check (non-interactive for run loop)
# Shows warning if deferred work found but proceeds with archiving
# Arguments: prd_file
# Returns: 0 on success, 1 on failure
_run_archive_with_deferred_check() {
    local prd_file="$1"

    # Check for deferred work before archiving
    local deferred_stories
    if deferred_stories=$(ar_check_deferred_work "$prd_file"); then
        log_warn "Deferred/scoped work detected in the following stories:"
        echo ""
        echo "$deferred_stories" | while IFS= read -r line; do
            echo "  - $line"
        done
        echo ""
        log_warn "Consider creating follow-up issues for this work."
        echo ""
    fi

    # Proceed with archive (using -y to skip interactive prompt)
    cmd_archive -y
    return $?
}

# Handle completion signals and archiving
# Arguments: output prd_file passes_before
# Returns: 0 to continue, 2 for user exit, 100 for completion
_run_handle_completion() {
    local output="$1"
    local prd_file="$2"
    local passes_before="${3:-}"

    # Check for completion signals (built-in)
    # Pass passes_before so quality check failures can rollback story completion
    local exit_signal
    exit_signal=$(ed_check "$output" "$prd_file" "$passes_before")

    # Also check custom completion patterns from hooks system
    if [[ "$exit_signal" == "continue" ]] && hk_check_completion_patterns "$output"; then
        # Custom pattern matched, but verify all stories are complete
        if all_stories_complete "$prd_file"; then
            exit_signal="complete"
        else
            log_warn "Custom completion pattern detected but not all stories complete - continuing"
        fi
    fi

    case "$exit_signal" in
        complete)
            # Run backpressure verification hook before accepting completion
            if ! _run_backpressure_gate "$prd_file" "$passes_before"; then
                # Backpressure verification failed - continue iteration
                return 0
            fi

            log_success "All stories complete!"

            # Execute on_completion hooks
            if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
                hk_on_completion || log_warn "Some on_completion hooks failed"
            fi

            if [[ "$RALPH_HYBRID_NO_ARCHIVE" != true ]]; then
                # Prompt user to archive
                echo ""
                read -r -p "Archive now? [y/N] " response
                case "$response" in
                    [yY][eE][sS]|[yY])
                        log_info "Archiving feature..."
                        _run_archive_with_deferred_check "$prd_file"
                        ;;
                    *)
                        log_info "Skipping archive. You can run 'ralph-hybrid archive' later."
                        ;;
                esac
            fi
            return "$RALPH_HYBRID_EXIT_COMPLETE"  # Special code for completion
            ;;
        story_complete)
            # Run backpressure verification hook before accepting story completion
            if ! _run_backpressure_gate "$prd_file" "$passes_before"; then
                # Backpressure verification failed - continue iteration
                return 0
            fi

            # One story completed successfully - continue to next iteration with fresh context
            log_success "Story completed! Starting fresh context for next story..."
            return 0  # Continue to next iteration
            ;;
        quality_check_failed)
            # Story was completed but quality checks failed - rolled back
            # This counts as progress attempt, don't penalize with circuit breaker
            log_warn "Quality checks failed - Claude will retry in same iteration"
            cb_record_progress  # Reset no-progress counter since work was done
            return 0  # Continue to next iteration
            ;;
        api_limit)
            log_warn "API limit detected in output."
            if ed_prompt_api_limit; then
                log_info "Waiting for limit reset..."
                sleep "$_RALPH_HYBRID_API_LIMIT_WAIT"
                return 0  # Continue to next iteration
            else
                log_info "User chose to exit."
                return "$RALPH_HYBRID_EXIT_USER"
            fi
            ;;
        continue)
            # No completion signal - continue to progress check
            return 0
            ;;
    esac

    return 0
}

# Run backpressure verification gate (post_iteration hook)
# This provides an additional verification layer on story completion.
# Hooks can run tests, lint, or other checks to ensure quality.
#
# Arguments:
#   $1 - Path to prd.json file
#   $2 - passes_before state (for rollback on failure)
#
# Returns:
#   0 - Verification passed (or hook not configured)
#   1 - Verification failed (story completion blocked)
#
# On failure:
#   - Rolls back story completion in prd.json
#   - Increments circuit breaker for VERIFICATION_FAILED (exit 75)
#   - Saves error feedback for next iteration
_run_backpressure_gate() {
    local prd_file="$1"
    local passes_before="${2:-}"

    # Check if hooks are enabled globally
    if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" != "true" ]]; then
        log_debug "Hooks disabled globally, skipping backpressure gate"
        return 0
    fi

    # Check if post_iteration hook is enabled in config
    local post_iteration_enabled
    post_iteration_enabled=$(cfg_get_value "hooks.post_iteration.enabled")
    if [[ "$post_iteration_enabled" == "false" ]]; then
        log_debug "Post-iteration hook disabled in config, skipping backpressure gate"
        return 0
    fi

    # Derive context from available information
    local feature_dir
    feature_dir=$(dirname "$prd_file")

    local iteration="${RALPH_HYBRID_ITERATION:-0}"
    local log_file="${feature_dir}/logs/iteration-${iteration}.log"

    # Get current story ID from prd.json (first incomplete story, or last story if all complete)
    local story_id
    story_id=$(jq -r '(.userStories[] | select(.passes == false) | .id) // (.userStories[-1].id) // "unknown"' "$prd_file" 2>/dev/null || echo "unknown")

    # Check if hook exists before running
    if ! hook_exists "post_iteration" "$feature_dir"; then
        log_debug "No post_iteration hook found, skipping backpressure gate"
        return 0
    fi

    # Load hook timeout from config if available
    local hook_timeout
    hook_timeout=$(cfg_get_value "hooks.timeout")
    if [[ -n "$hook_timeout" ]]; then
        export RALPH_HYBRID_HOOK_TIMEOUT="$hook_timeout"
    fi

    log_info "Running backpressure verification hook..."

    # Run the post_iteration hook
    local hook_exit_code=0
    run_hook "post_iteration" "$story_id" "$iteration" "$feature_dir" "$log_file" || hook_exit_code=$?

    if [[ $hook_exit_code -eq 0 ]]; then
        log_info "Backpressure verification passed"
        return 0
    fi

    # Hook failed - handle based on exit code
    if [[ $hook_exit_code -eq 75 ]]; then
        # VERIFICATION_FAILED - tests/lint/etc. failed
        log_error "Backpressure verification FAILED (hook returned VERIFICATION_FAILED)"
        log_error "Story completion blocked - Claude should fix issues and retry"

        # Save error feedback for next iteration
        cat > "${feature_dir}/last_error.txt" << 'EOF'
Backpressure Verification Failed
=================================

The post-iteration verification hook failed. This typically means:
- Tests did not pass
- Linting checks failed
- Type checking failed
- Build failed

Your implementation does not meet the project's quality standards.
You MUST fix all issues before the story can be marked as complete.

Review the hook output above for specific errors to fix.
EOF
        log_warn "Error feedback saved to ${feature_dir}/last_error.txt"

        # Rollback story completion
        if [[ -n "$passes_before" ]] && [[ -n "$prd_file" ]]; then
            if declare -f prd_rollback_passes &>/dev/null; then
                log_error "Rolling back story completion..."
                prd_rollback_passes "$prd_file" "$passes_before"
            fi
        fi

        # Increment circuit breaker - this is a verification failure
        cb_record_no_progress
        cb_save_state

        return 1
    else
        # Other hook error (non-75)
        log_warn "Backpressure hook failed with exit code $hook_exit_code (infrastructure error)"
        log_warn "Allowing story completion despite hook failure"
        # Infrastructure errors don't block completion - only VERIFICATION_FAILED does
        return 0
    fi
}

#=============================================================================
# Run Command - Private Helper: Single Iteration
#=============================================================================

# Execute a single iteration of the development loop
# Arguments: iteration_num feature_dir prd_file timeout_cmd feature_name
# Returns: 0 to continue, 1 to stop with error, 2 for user exit, 100 for completion
_run_iteration() {
    local iteration="$1"
    local feature_dir="$2"
    local prd_file="$3"
    local timeout_cmd="$4"
    local feature_name="$5"

    # Record iteration start time for timeout countdown
    local iteration_start_time
    iteration_start_time=$(date +%s)

    # Get cursor row BEFORE drawing title bar to calculate timer position accurately
    # Title bar structure: empty line, top border, feature name, story+timer, progress, bottom border, empty line
    # Timer is on line 4 (0-indexed: 3) from the start
    local term_width
    term_width=$(_get_terminal_width)
    local start_row
    start_row=$(_get_cursor_row)
    # Ensure start_row is at least 1 (minimum valid row)
    if [[ $start_row -lt 1 ]]; then
        start_row=1
    fi
    local timer_row=$((start_row + 3))

    # Display the title bar with full context and timeout countdown
    _display_title_bar "$feature_name" "$prd_file" "$iteration" "$RALPH_HYBRID_MAX_ITERATIONS" "$iteration_start_time" "$RALPH_HYBRID_TIMEOUT_MINUTES"

    # Start background countdown timer updater
    _start_countdown_timer "$timer_row" "$iteration_start_time" "$RALPH_HYBRID_TIMEOUT_MINUTES" "$term_width"

    # Export iteration number for hooks
    export RALPH_HYBRID_ITERATION="$iteration"

    # Execute pre_iteration hooks
    if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
        hk_pre_iteration || log_warn "Some pre_iteration hooks failed"
    fi

    # Check circuit breaker
    if ! cb_check; then
        _stop_countdown_timer  # Stop timer before early return
        log_error "Circuit breaker tripped! Stopping loop."
        cb_get_status
        # Execute on_error hooks
        if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
            export RALPH_HYBRID_ERROR_TYPE="circuit_breaker"
            hk_on_error || log_warn "Some on_error hooks failed"
            unset RALPH_HYBRID_ERROR_TYPE
        fi
        return 1
    fi

    # Check rate limit
    rl_check_hour_reset
    if ! rl_check; then
        _stop_countdown_timer  # Stop timer during rate limit wait
        log_warn "Rate limit reached."
        rl_wait_for_reset
        # Restart timer after wait (reset start time)
        iteration_start_time=$(date +%s)
        _start_countdown_timer "$timer_row" "$iteration_start_time" "$RALPH_HYBRID_TIMEOUT_MINUTES" "$term_width"
    fi

    # Snapshot passes state before
    local passes_before
    passes_before=$(get_passes_state "$prd_file")

    # Build prompt (pass iteration number for timestamp context)
    local prompt_content
    prompt_content=$(build_prompt "$feature_dir" "$RALPH_HYBRID_PROMPT_FILE" "$iteration")

    # Ensure logs directory exists
    mkdir -p "${feature_dir}/logs"
    local log_file="${feature_dir}/logs/iteration-${iteration}.log"

    # Invoke Claude CLI
    _run_invoke_claude "$prompt_content" "$timeout_cmd" "$log_file" "$iteration"

    # Stop the countdown timer updater
    _stop_countdown_timer

    # Handle timeout
    if [[ $INVOKE_EXIT_CODE -eq $RALPH_HYBRID_EXIT_TIMEOUT ]]; then
        log_warn "Iteration timed out after ${RALPH_HYBRID_TIMEOUT_MINUTES} minutes"

        # Read output from log for context
        local timeout_output
        timeout_output=$(cat "$log_file" 2>/dev/null || true)

        # Show interrupted work context
        ed_show_interrupted_context "$prd_file" "$timeout_output"

        # IMPORTANT: Check prd.json even on timeout - Claude may have updated it
        # before the timeout hit. This prevents infinite loops where work is done
        # but progress is not detected.
        local passes_after_timeout
        passes_after_timeout=$(get_passes_state "$prd_file")

        if cb_detect_progress "$passes_before" "$passes_after_timeout"; then
            log_success "Progress detected despite timeout (prd.json was updated)"
            cb_record_progress

            # Also check if all stories are now complete
            if all_stories_complete "$prd_file"; then
                log_success "All stories complete (detected after timeout)!"
                cb_save_state

                # Execute on_completion hooks
                if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
                    hk_on_completion || log_warn "Some on_completion hooks failed"
                fi

                if [[ "$RALPH_HYBRID_NO_ARCHIVE" != true ]]; then
                    echo ""
                    read -r -p "Archive now? [y/N] " response
                    case "$response" in
                        [yY][eE][sS]|[yY])
                            log_info "Archiving feature..."
                            _run_archive_with_deferred_check "$prd_file"
                            ;;
                        *)
                            log_info "Skipping archive. You can run 'ralph-hybrid archive' later."
                            ;;
                    esac
                fi
                return $RALPH_HYBRID_EXIT_COMPLETE
            fi
        else
            cb_record_no_progress
        fi
        cb_save_state
        return 0  # Continue to next iteration
    fi

    # Read output from log for completion detection
    local output
    output=$(cat "$log_file")

    # Handle completion signals (pass passes_before for quality check rollback)
    local completion_result=0
    _run_handle_completion "$output" "$prd_file" "$passes_before" || completion_result=$?
    if [[ $completion_result -ne 0 ]]; then
        return $completion_result
    fi

    # Check for progress
    local passes_after
    passes_after=$(get_passes_state "$prd_file")

    if cb_detect_progress "$passes_before" "$passes_after"; then
        log_success "Progress detected!"
        cb_record_progress
    else
        log_warn "No progress this iteration."
        cb_record_no_progress
    fi

    # Extract and record any errors
    local error_msg
    error_msg=$(ed_extract_error "$output")
    if [[ -n "$error_msg" ]]; then
        log_warn "Error detected: ${error_msg}"
        cb_record_error "$error_msg"
    fi

    # Save circuit breaker state
    cb_save_state

    # Verbose output
    if [[ "$RALPH_HYBRID_VERBOSE" == true ]]; then
        echo "--- Claude Output ---"
        echo "$output" | head -"$_RALPH_HYBRID_VERBOSE_OUTPUT_LINES"
        echo "--- End Output ---"
    fi

    # Execute post_iteration hooks
    if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
        hk_post_iteration || log_warn "Some post_iteration hooks failed"
    fi

    return 0  # Continue to next iteration
}

#=============================================================================
# Run Command - Private Helper: Lock Acquisition
#=============================================================================

# Acquire lock to prevent concurrent ralph runs
# Sets: RUN_ABS_FEATURE_DIR (for lock release)
# Returns: 0 on success, 1 on failure
_run_acquire_lock() {
    RUN_ABS_FEATURE_DIR="$(cd "$(dirname "$RUN_FEATURE_DIR")" && pwd)/$(basename "$RUN_FEATURE_DIR")"
    if ! lf_acquire "$RUN_ABS_FEATURE_DIR"; then
        log_error "Cannot acquire lock. Another ralph instance may be running."
        return 1
    fi
    return 0
}

#=============================================================================
# Run Command - Private Helper: Build Monitor Command
#=============================================================================

# Build the ralph-hybrid run command for monitor mode (without --monitor)
# Outputs: command string to stdout
_run_build_monitor_cmd() {
    local run_cmd="ralph-hybrid run"
    [[ -n "${RALPH_HYBRID_MAX_ITERATIONS:-}" ]] && run_cmd+=" -n $RALPH_HYBRID_MAX_ITERATIONS"
    [[ -n "${RALPH_HYBRID_TIMEOUT_MINUTES:-}" ]] && run_cmd+=" -t $RALPH_HYBRID_TIMEOUT_MINUTES"
    [[ -n "${RALPH_HYBRID_RATE_LIMIT:-}" ]] && run_cmd+=" -r $RALPH_HYBRID_RATE_LIMIT"
    [[ -n "${RALPH_HYBRID_PROMPT_FILE:-}" ]] && run_cmd+=" -p $RALPH_HYBRID_PROMPT_FILE"
    [[ "$RALPH_HYBRID_VERBOSE" == true ]] && run_cmd+=" -v"
    [[ "$RALPH_HYBRID_NO_ARCHIVE" == true ]] && run_cmd+=" --no-archive"
    [[ "$RALPH_HYBRID_SKIP_PREFLIGHT" == true ]] && run_cmd+=" --skip-preflight"
    [[ "$RALPH_HYBRID_DANGEROUSLY_SKIP_PERMISSIONS" == true ]] && run_cmd+=" --dangerously-skip-permissions"
    [[ -n "${RALPH_HYBRID_MODEL:-}" ]] && run_cmd+=" -m $RALPH_HYBRID_MODEL"
    [[ -n "${RALPH_HYBRID_PROFILE:-}" ]] && run_cmd+=" --profile $RALPH_HYBRID_PROFILE"
    echo "$run_cmd"
}

#=============================================================================
# Run Command - Private Helper: Already Complete Check
#=============================================================================

# Check if all stories are already complete and handle archiving
# Returns: 0 if handled (caller should exit), 1 if not complete (continue)
_run_check_already_complete() {
    if ! all_stories_complete "$RUN_PRD_FILE"; then
        return 1  # Not complete, continue
    fi

    log_success "All stories already complete!"
    if [[ "$RALPH_HYBRID_NO_ARCHIVE" != true ]]; then
        echo ""
        read -r -p "Archive now? [y/N] " response
        case "$response" in
            [yY][eE][sS]|[yY])
                log_info "Archiving feature..."
                _run_archive_with_deferred_check "$RUN_PRD_FILE"
                ;;
            *)
                log_info "Skipping archive. You can run 'ralph-hybrid archive' later."
                ;;
        esac
    fi
    return 0  # Handled
}

#=============================================================================
# Run Command - Private Helper: Exit with Hooks
#=============================================================================

# Execute post_run hooks with status and release lock
# Arguments: status (complete|error|user_exit), [error_type]
# Returns: appropriate exit code
_run_exit_with_hooks() {
    local status="$1"
    local error_type="${2:-}"

    # Execute on_error hooks if error type specified
    if [[ -n "$error_type" ]] && [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
        export RALPH_HYBRID_ERROR_TYPE="$error_type"
        hk_on_error || log_warn "Some on_error hooks failed"
        unset RALPH_HYBRID_ERROR_TYPE
    fi

    # Execute post_run hooks
    if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
        export RALPH_HYBRID_RUN_STATUS="$status"
        hk_post_run || log_warn "Some post_run hooks failed"
        unset RALPH_HYBRID_RUN_STATUS
    fi

    lf_release

    # Return appropriate exit code
    case "$status" in
        complete) return "$RALPH_HYBRID_EXIT_SUCCESS" ;;
        error)    return "$RALPH_HYBRID_EXIT_ERROR" ;;
        user_exit) return "$RALPH_HYBRID_EXIT_USER" ;;
        *)        return "$RALPH_HYBRID_EXIT_ERROR" ;;
    esac
}

#=============================================================================
# Run Command - Private Helper: Main Iteration Loop
#=============================================================================

# Run the main iteration loop
# Arguments: timeout_cmd
# Returns: exit code from loop (success, error, user, complete)
_run_main_loop() {
    local timeout_cmd="$1"

    # Initialize monitor status
    mon_write_status 0 "starting" 0 0 0 0 ""

    # Execute pre_run hooks
    if [[ "${RALPH_HYBRID_HOOKS_ENABLED:-true}" == "true" ]]; then
        hk_pre_run || log_warn "Some pre_run hooks failed"
    fi

    log_info "Starting Ralph loop for feature: ${RUN_FEATURE_NAME}"
    log_info "Max iterations: ${RALPH_HYBRID_MAX_ITERATIONS}, Timeout: ${RALPH_HYBRID_TIMEOUT_MINUTES}m"

    local iteration=0
    while [[ $iteration -lt $RALPH_HYBRID_MAX_ITERATIONS ]]; do
        iteration=$((iteration + 1))
        mon_iteration_start "$iteration" "$RUN_PRD_FILE" ""

        local iter_result=0
        _run_iteration "$iteration" "$RUN_FEATURE_DIR" "$RUN_PRD_FILE" "$timeout_cmd" "$RUN_FEATURE_NAME" || iter_result=$?

        case $iter_result in
            "$RALPH_HYBRID_EXIT_SUCCESS")
                mon_iteration_end "$iteration" "$RUN_PRD_FILE" "running" ""
                sleep "$_RALPH_HYBRID_ITERATION_SLEEP"
                ;;
            "$RALPH_HYBRID_EXIT_ERROR")
                mon_mark_error "$RUN_PRD_FILE"
                _run_exit_with_hooks "error"
                return $?
                ;;
            "$RALPH_HYBRID_EXIT_USER")
                mon_iteration_end "$iteration" "$RUN_PRD_FILE" "paused" ""
                _run_exit_with_hooks "user_exit"
                return $?
                ;;
            "$RALPH_HYBRID_EXIT_COMPLETE")
                mon_mark_complete "$RUN_PRD_FILE"
                _run_exit_with_hooks "complete"
                return $?
                ;;
        esac
    done

    # Max iterations reached
    mon_mark_error "$RUN_PRD_FILE"
    log_error "Max iterations (${RALPH_HYBRID_MAX_ITERATIONS}) reached without completion."
    _run_exit_with_hooks "error" "max_iterations"
    return $?
}

#=============================================================================
# Run Command - Main Loop
#=============================================================================

cmd_run() {
    # Validate arguments and run preflight checks
    _run_validate_args "$@" || return 1

    # Setup state (sets RUN_FEATURE_NAME, RUN_FEATURE_DIR, RUN_PRD_FILE)
    _run_setup_state || return 1

    # Acquire lock
    _run_acquire_lock || return 1
    export RALPH_HYBRID_FEATURE_NAME="$RUN_FEATURE_NAME"

    # Dry run mode
    if [[ "$RALPH_HYBRID_DRY_RUN" == true ]]; then
        run_show_dry_run "$RUN_FEATURE_NAME" "$RUN_FEATURE_DIR"
        lf_release
        return 0
    fi

    # Monitor mode - launch in tmux
    if [[ "$RALPH_HYBRID_MONITOR" == true ]]; then
        local run_cmd
        run_cmd=$(_run_build_monitor_cmd)
        lf_release  # Inner run will acquire its own lock
        mon_start_dashboard "$run_cmd"
        return $?
    fi

    # Check if already complete
    if _run_check_already_complete; then
        lf_release
        return 0
    fi

    # Get timeout command
    local timeout_cmd
    if ! timeout_cmd=$(get_timeout_cmd); then
        lf_release
        return 1
    fi

    # Run main loop (handles its own exit with hooks)
    _run_main_loop "$timeout_cmd"
}

#=============================================================================
# Main Entry Point
#=============================================================================

main() {
    # Check bash version
    check_bash_version

    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        return 0
    fi

    local command="${1:-}"
    shift || true

    case "$command" in
        help|-h|--help)
            show_help
            return 0
            ;;
        version|--version|-V)
            show_version
            return 0
            ;;
        status)
            cmd_status "$@"
            return $?
            ;;
        monitor)
            cmd_monitor "$@"
            return $?
            ;;
        kill)
            cmd_kill "$@"
            return $?
            ;;
        archive)
            cmd_archive "$@"
            return $?
            ;;
        restore)
            cmd_restore "$@"
            return $?
            ;;
        validate)
            cmd_validate "$@"
            return $?
            ;;
        verify)
            cmd_verify "$@"
            return $?
            ;;
        integrate)
            cmd_integrate "$@"
            return $?
            ;;
        debug)
            cmd_debug "$@"
            return $?
            ;;
        setup)
            cmd_setup "$@"
            return $?
            ;;
        import)
            cmd_import "$@"
            return $?
            ;;
        run)
            cmd_run "$@"
            return $?
            ;;
        *)
            log_error "Unknown command: ${command}"
            echo "" >&2
            show_help
            return 1
            ;;
    esac
}

# Cleanup function to kill child processes
cleanup() {
    # Disable the trap immediately to prevent recursive calls
    trap - INT TERM

    # Show cursor again (in case we were in scrolling window)
    printf '\e[?25h' 2>/dev/null || true
    echo "" 2>/dev/null || true

    # Use logging if available, otherwise just echo
    if declare -f log_warn &>/dev/null; then
        log_warn "Interrupted by user - cleaning up..."
    else
        echo "Interrupted by user - cleaning up..." >&2
    fi

    # Stop countdown timer if running
    _stop_countdown_timer 2>/dev/null || true

    # Release lockfile FIRST (most important)
    if declare -f lf_release &>/dev/null; then
        lf_release 2>/dev/null || true
    fi

    # Kill all child processes (works on both Linux and macOS)
    # pkill -P $$ kills all children of our PID
    pkill -TERM -P $$ 2>/dev/null || true
    sleep 0.2
    pkill -KILL -P $$ 2>/dev/null || true

    # Also kill any claude/timeout processes we spawned (backup method)
    pkill -f "claude -p --permission-mode" 2>/dev/null || true
    pkill -f "timeout.*claude" 2>/dev/null || true
    pkill -f "gtimeout.*claude" 2>/dev/null || true

    # macOS-specific: Use pgrep to find all descendants and kill them
    local descendants
    descendants=$(pgrep -P $$ 2>/dev/null || true)
    if [[ -n "$descendants" ]]; then
        kill -TERM $descendants 2>/dev/null || true
        sleep 0.2
        kill -KILL $descendants 2>/dev/null || true
    fi

    exit "$RALPH_HYBRID_EXIT_INTERRUPT"
}

# Handle Ctrl+C gracefully
trap cleanup INT TERM

# Run main
main "$@"
