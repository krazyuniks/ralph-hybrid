#!/usr/bin/env bash
# Ralph Hybrid - Main Script
# Autonomous development loop orchestrator for Claude Code
#
# Usage: ralph <command> [options]
# Commands: run, status, archive, validate, help, version
#
# Note: Feature folder is automatically derived from current git branch.

set -euo pipefail

#=============================================================================
# Constants
#=============================================================================

RALPH_VERSION="0.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

#=============================================================================
# Source Libraries
#=============================================================================

source "${SCRIPT_DIR}/lib/utils.sh"
source "${SCRIPT_DIR}/lib/preflight.sh"
source "${SCRIPT_DIR}/lib/circuit_breaker.sh"
source "${SCRIPT_DIR}/lib/rate_limiter.sh"
source "${SCRIPT_DIR}/lib/exit_detection.sh"
source "${SCRIPT_DIR}/lib/archive.sh"

#=============================================================================
# Global Variables (set by parse_args or load_config)
#=============================================================================

# Run options
RALPH_MAX_ITERATIONS="${RALPH_MAX_ITERATIONS:-20}"
RALPH_TIMEOUT_MINUTES="${RALPH_TIMEOUT_MINUTES:-15}"
RALPH_RATE_LIMIT="${RALPH_RATE_LIMIT:-100}"
RALPH_PROMPT_FILE=""
RALPH_VERBOSE=false
RALPH_NO_ARCHIVE=false
RALPH_RESET_CIRCUIT=false
RALPH_DRY_RUN=false
RALPH_SKIP_PREFLIGHT=false
RALPH_DANGEROUSLY_SKIP_PERMISSIONS="${RALPH_DANGEROUSLY_SKIP_PERMISSIONS:-false}"

#=============================================================================
# Help / Usage
#=============================================================================

show_help() {
    cat << 'EOF'
Ralph Hybrid - Autonomous Development Loop for Claude Code

Usage: ralph <command> [options]

Commands:
  run [options]          Execute the development loop
  status                 Show current feature status
  archive                Archive a completed feature
  validate               Run preflight checks without starting loop
  help                   Show this help message
  version                Show version information

Note: Feature folder is automatically derived from current git branch.
      Use /ralph-plan in Claude Code to create feature files.

Run Options:
  -n, --max-iterations N     Maximum iterations (default: 20)
  -t, --timeout N            Per-iteration timeout in minutes (default: 15)
  -r, --rate-limit N         Max API calls per hour (default: 100)
  -p, --prompt FILE          Custom prompt file
  -v, --verbose              Enable verbose output
  --no-archive               Don't archive on completion
  --reset-circuit            Reset circuit breaker state before running
  --dry-run                  Show what would happen without executing
  --skip-preflight           Skip preflight validation (use with caution)
  --dangerously-skip-permissions  Pass to Claude Code
  -m, --model MODEL          Claude model (opus, sonnet, or full name)

Examples:
  ralph run -n 30 -t 20
  ralph status
  ralph archive
  ralph validate

For more information, see: https://github.com/krazyuniks/ralph-hybrid
EOF
}

show_version() {
    echo "ralph version ${RALPH_VERSION}"
}

#=============================================================================
# Prerequisite Checks
#=============================================================================

# Check all required commands are available
check_prerequisites() {
    local missing=()

    if ! command -v claude &>/dev/null; then
        missing+=("claude")
    fi

    if ! command -v jq &>/dev/null; then
        missing+=("jq")
    fi

    if ! command -v git &>/dev/null; then
        missing+=("git")
    fi

    # Check for timeout command
    if ! get_timeout_cmd &>/dev/null; then
        missing+=("timeout (install coreutils on macOS)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Required commands not found: ${missing[*]}"
        log_error "Please install the missing dependencies."
        return 1
    fi

    return 0
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir &>/dev/null; then
        log_error "Not in a git repository. Please initialize git first."
        return 1
    fi
    return 0
}

# Note: get_ralph_dir() and get_feature_dir() are now provided by lib/utils.sh

#=============================================================================
# Status Command
#=============================================================================

cmd_status() {
    # No arguments expected - feature auto-detected from branch
    if [[ $# -gt 0 ]]; then
        log_error "Unknown option: $1"
        return 1
    fi

    # Get feature directory from current git branch
    local feature_dir
    feature_dir=$(get_feature_dir) || return 1

    local prd_file="${feature_dir}/prd.json"

    # Get feature name from directory for display
    local feature_name
    feature_name=$(basename "$feature_dir")

    if [[ ! -f "$prd_file" ]]; then
        log_error "prd.json not found for feature: ${feature_name}"
        return 1
    fi

    # Get story counts
    local total passed
    total=$(get_prd_total_stories "$prd_file")
    passed=$(get_prd_passes_count "$prd_file")

    # Get current branch (for display only - feature is derived from folder)
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")

    echo "=========================================="
    echo "Feature: ${feature_name}"
    echo "=========================================="
    echo "Stories: ${passed}/${total} complete"
    echo "Current branch: ${current_branch}"
    echo ""

    # Show circuit breaker state if it exists
    export RALPH_STATE_DIR="${feature_dir}"
    if [[ -f "${feature_dir}/circuit_breaker.state" ]]; then
        cb_load_state
        cb_get_status
    else
        echo "Circuit Breaker: Not initialized"
    fi
    echo ""

    # Show stories
    echo "Stories:"
    jq -r '.userStories[] | "  [\(if .passes then "X" else " " end)] \(.id): \(.title)"' "$prd_file"

    return 0
}

#=============================================================================
# Archive Command
#=============================================================================

cmd_archive() {
    # No arguments expected - feature auto-detected from branch
    if [[ $# -gt 0 ]]; then
        log_error "Unknown option: $1"
        return 1
    fi

    # Get feature directory from current git branch
    local feature_dir
    feature_dir=$(get_feature_dir) || return 1

    local ralph_dir
    ralph_dir=$(get_ralph_dir)

    # Get feature name from directory
    local feature_name
    feature_name=$(basename "$feature_dir")

    # Use archive library
    local archive_path
    archive_path=$(ar_create_archive "$feature_name" "$ralph_dir") || return 1

    # Remove original
    ar_cleanup_feature "$feature_name" "$ralph_dir" || return 1

    log_success "Feature archived to: ${archive_path}"
    return 0
}

#=============================================================================
# Validate Command
#=============================================================================

cmd_validate() {
    # No arguments expected - feature auto-detected from branch
    if [[ $# -gt 0 ]]; then
        log_error "Unknown option: $1"
        return 1
    fi

    # Check git repo first
    if ! check_git_repo; then
        return 1
    fi

    # Run all preflight checks (feature_dir auto-detected from branch)
    pf_run_all_checks
    return $?
}

#=============================================================================
# Run Command - Argument Parsing
#=============================================================================

parse_run_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--max-iterations)
                RALPH_MAX_ITERATIONS="${2:-}"
                shift 2
                ;;
            -t|--timeout)
                RALPH_TIMEOUT_MINUTES="${2:-}"
                shift 2
                ;;
            -r|--rate-limit)
                RALPH_RATE_LIMIT="${2:-}"
                shift 2
                ;;
            -p|--prompt)
                RALPH_PROMPT_FILE="${2:-}"
                shift 2
                ;;
            -v|--verbose)
                RALPH_VERBOSE=true
                export RALPH_DEBUG=1
                shift
                ;;
            --no-archive)
                RALPH_NO_ARCHIVE=true
                shift
                ;;
            --reset-circuit)
                RALPH_RESET_CIRCUIT=true
                shift
                ;;
            --dry-run)
                RALPH_DRY_RUN=true
                shift
                ;;
            --skip-preflight)
                RALPH_SKIP_PREFLIGHT=true
                shift
                ;;
            --dangerously-skip-permissions)
                RALPH_DANGEROUSLY_SKIP_PERMISSIONS=true
                shift
                ;;
            -m|--model)
                RALPH_MODEL="${2:-}"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                # No positional arguments expected
                log_error "Unknown argument: $1"
                return 1
                ;;
        esac
    done

    return 0
}

#=============================================================================
# Run Command - Build Prompt
#=============================================================================

build_prompt() {
    local feature_dir="$1"
    local prompt_file="${2:-}"

    local prd_file="${feature_dir}/prd.json"
    local progress_file="${feature_dir}/progress.txt"
    local specs_dir="${feature_dir}/specs"
    local default_prompt="${feature_dir}/prompt.md"

    # Determine which prompt to use
    local prompt_path
    if [[ -n "$prompt_file" ]] && [[ -f "$prompt_file" ]]; then
        prompt_path="$prompt_file"
    elif [[ -f "$default_prompt" ]]; then
        prompt_path="$default_prompt"
    else
        prompt_path="${SCRIPT_DIR}/templates/prompt-tdd.md"
    fi

    # Build the combined prompt with inline file contents
    # Note: @ file references don't work with claude -p mode, so we inline everything
    cat << EOF
$(cat "$prompt_path")

---

## prd.json

\`\`\`json
$(cat "$prd_file")
\`\`\`

---

## progress.txt

\`\`\`
$(cat "$progress_file")
\`\`\`

---

## specs/

$(
    if [[ -d "$specs_dir" ]]; then
        for spec_file in "$specs_dir"/*; do
            if [[ -f "$spec_file" ]]; then
                local fname
                fname=$(basename "$spec_file")
                echo "### $fname"
                echo ""
                echo '```'
                cat "$spec_file"
                echo '```'
                echo ""
            fi
        done
    else
        echo "(no specs directory)"
    fi
)
EOF
}

#=============================================================================
# Run Command - Validation and Setup
#=============================================================================

# Validate prerequisites, git repo, and get feature from branch
# Sets: RUN_FEATURE_NAME, RUN_FEATURE_DIR, RUN_PRD_FILE
# Returns: 0 on success, 1 on failure
run_validate_setup() {
    # Check prerequisites
    if ! check_prerequisites; then
        return 1
    fi

    # Check git repo
    if ! check_git_repo; then
        return 1
    fi

    # Load configuration
    load_config

    # Override config with CLI args (already done via parse_run_args)
    export RALPH_RATE_LIMIT

    # Get feature directory from current git branch
    RUN_FEATURE_DIR=$(get_feature_dir) || return 1
    RUN_FEATURE_NAME=$(basename "$RUN_FEATURE_DIR")
    RUN_PRD_FILE="${RUN_FEATURE_DIR}/prd.json"

    # Verify prd.json exists
    if [[ ! -f "$RUN_PRD_FILE" ]]; then
        log_error "prd.json not found: ${RUN_PRD_FILE}"
        return 1
    fi

    # Verify custom prompt file if specified
    if [[ -n "$RALPH_PROMPT_FILE" ]] && [[ ! -f "$RALPH_PROMPT_FILE" ]]; then
        log_error "Prompt file not found: ${RALPH_PROMPT_FILE}"
        return 1
    fi

    # Set up state directory for this feature
    export RALPH_STATE_DIR="${RUN_FEATURE_DIR}"

    return 0
}

#=============================================================================
# Run Command - Dry Run Display
#=============================================================================

# Display dry run information without executing
run_show_dry_run() {
    local feature_name="$1"
    local feature_dir="$2"

    echo "=========================================="
    echo "DRY RUN - Would execute the following:"
    echo "=========================================="
    echo "Feature: ${feature_name}"
    echo "Max iterations: ${RALPH_MAX_ITERATIONS}"
    echo "Timeout: ${RALPH_TIMEOUT_MINUTES} minutes"
    echo "Rate limit: ${RALPH_RATE_LIMIT}/hour"
    echo "Auto-archive: $([ "$RALPH_NO_ARCHIVE" = true ] && echo "no" || echo "yes")"
    echo "Skip permissions: ${RALPH_DANGEROUSLY_SKIP_PERMISSIONS}"
    echo ""
    echo "Prompt preview:"
    echo "---"
    build_prompt "$feature_dir" "$RALPH_PROMPT_FILE" | head -20
    echo "..."
    echo "---"
}

#=============================================================================
# Run Command - State Initialization
#=============================================================================

# Initialize circuit breaker and rate limiter
# Returns: 0 on success
run_initialize_state() {
    # Reset circuit breaker if requested
    if [[ "$RALPH_RESET_CIRCUIT" == true ]]; then
        cb_reset
    fi

    # Initialize circuit breaker and rate limiter
    cb_load_state
    rl_load_state

    return 0
}

#=============================================================================
# Run Command - Single Iteration
#=============================================================================

# Execute a single iteration of the development loop
# Arguments: iteration_num feature_dir prd_file timeout_cmd
# Returns: 0 to continue, 1 to stop with error, 2 for user exit, 100 for completion
run_single_iteration() {
    local iteration="$1"
    local feature_dir="$2"
    local prd_file="$3"
    local timeout_cmd="$4"
    local feature_name="$5"

    log_info "========== Iteration ${iteration}/${RALPH_MAX_ITERATIONS} =========="

    # Check circuit breaker
    if ! cb_check; then
        log_error "Circuit breaker tripped! Stopping loop."
        cb_get_status
        return 1
    fi

    # Check rate limit
    rl_check_hour_reset
    if ! rl_check; then
        log_warn "Rate limit reached."
        rl_wait_for_reset
    fi

    # Snapshot passes state before
    local passes_before
    passes_before=$(get_passes_state "$prd_file")

    # Build prompt
    local prompt_content
    prompt_content=$(build_prompt "$feature_dir" "$RALPH_PROMPT_FILE")

    # Build claude command args
    # Note: --permission-mode bypassPermissions works with -p mode
    # while --dangerously-skip-permissions causes hangs
    local claude_args="--permission-mode bypassPermissions"

    # Add model if specified
    if [[ -n "${RALPH_MODEL:-}" ]]; then
        claude_args+=" --model ${RALPH_MODEL}"
    fi

    # Ensure logs directory exists
    mkdir -p "${feature_dir}/logs"
    local log_file="${feature_dir}/logs/iteration-${iteration}.log"

    # Run Claude with timeout and real-time output
    log_info "Running Claude Code..."
    local exit_code=0

    # Initialize log file
    echo "=== Iteration ${iteration} ===" > "$log_file"
    echo "Timestamp: $(get_timestamp)" >> "$log_file"
    echo "" >> "$log_file"

    set +e
    # Use stream-json for real-time visibility, tee to log file
    # Parse JSON stream to show activity while also saving raw output
    echo "$prompt_content" | $timeout_cmd "${RALPH_TIMEOUT_MINUTES}m" \
        claude -p $claude_args --output-format stream-json --verbose 2>&1 | \
        tee -a "$log_file" | \
        {
            # Scrolling window - keep last 8 lines visible
            declare -a buffer=()
            local window_size=8
            local line_count=0

            # Hide cursor during updates
            printf '\e[?25l'

            # Print empty lines to create window space
            for ((i=0; i<window_size; i++)); do echo ""; done

            while IFS= read -r line; do
                # Parse JSON and extract display text
                local display=""
                if echo "$line" | jq -e '.message.content' &>/dev/null; then
                    display=$(echo "$line" | jq -r '
                        .message.content[]? |
                        if .type == "text" then
                            "  ðŸ’¬ " + (.text | split("\n")[0] | .[0:90])
                        elif .type == "tool_use" then
                            "  ðŸ”§ " + .name + ": " + (.input | tostring | .[0:50])
                        else empty end
                    ' 2>/dev/null)
                elif echo "$line" | jq -e '.type == "result"' &>/dev/null; then
                    display=$(echo "$line" | jq -r '"  âœ… Done: " + (.result | .[0:70])' 2>/dev/null)
                fi

                # Add to buffer if we have display text
                if [[ -n "$display" ]]; then
                    while IFS= read -r dline; do
                        [[ -n "$dline" ]] && buffer+=("$dline")
                    done <<< "$display"

                    # Keep only last window_size lines
                    while [[ ${#buffer[@]} -gt $window_size ]]; do
                        buffer=("${buffer[@]:1}")
                    done

                    # Move cursor up and redraw window
                    printf '\e[%dA' "$window_size"  # Move up
                    printf '\e[J'                    # Clear to end of screen

                    # Print buffer with padding
                    for ((i=0; i<window_size; i++)); do
                        if [[ $i -lt ${#buffer[@]} ]]; then
                            printf '%s\n' "${buffer[$i]}"
                        else
                            echo ""
                        fi
                    done
                fi
            done

            # Show cursor again
            printf '\e[?25h'
        }
    exit_code=${PIPESTATUS[1]}
    set -e

    echo "Exit code: ${exit_code}" >> "$log_file"
    log_info "Output saved to: ${log_file}"

    # Read output from log for completion detection
    local output
    output=$(cat "$log_file")

    # Record API call
    rl_record_call

    # Handle timeout
    if [[ $exit_code -eq 124 ]]; then
        log_warn "Iteration timed out after ${RALPH_TIMEOUT_MINUTES} minutes"
        cb_record_no_progress
        cb_save_state
        return 0  # Continue to next iteration
    fi

    # Check for completion signals
    local exit_signal
    exit_signal=$(ed_check "$output" "$prd_file")

    case "$exit_signal" in
        complete)
            log_success "Completion signal detected!"
            if [[ "$RALPH_NO_ARCHIVE" != true ]]; then
                log_info "Archiving feature..."
                cmd_archive
            fi
            return 100  # Special code for completion
            ;;
        api_limit)
            log_warn "API limit detected in output."
            if ed_prompt_api_limit; then
                log_info "Waiting for limit reset..."
                sleep 300
                return 0  # Continue to next iteration
            else
                log_info "User chose to exit."
                return 2
            fi
            ;;
        continue)
            # Continue to progress check
            ;;
    esac

    # Check for progress
    local passes_after
    passes_after=$(get_passes_state "$prd_file")

    if cb_detect_progress "$passes_before" "$passes_after"; then
        log_success "Progress detected!"
        cb_record_progress
    else
        log_warn "No progress this iteration."
        cb_record_no_progress
    fi

    # Extract and record any errors
    local error_msg
    error_msg=$(ed_extract_error "$output")
    if [[ -n "$error_msg" ]]; then
        log_warn "Error detected: ${error_msg}"
        cb_record_error "$error_msg"
    fi

    # Save circuit breaker state
    cb_save_state

    # Verbose output
    if [[ "$RALPH_VERBOSE" == true ]]; then
        echo "--- Claude Output ---"
        echo "$output" | head -50
        echo "--- End Output ---"
    fi

    return 0  # Continue to next iteration
}

#=============================================================================
# Run Command - Main Loop
#=============================================================================

cmd_run() {
    # Parse arguments
    parse_run_args "$@" || return 1

    # Run preflight checks (unless skipped)
    if [[ "$RALPH_SKIP_PREFLIGHT" == true ]]; then
        log_warn "Skipping preflight validation (--skip-preflight). Use with caution."
    else
        # Check git repo first (required for preflight)
        if ! check_git_repo; then
            return 1
        fi

        # Run all preflight checks
        if ! pf_run_all_checks; then
            return 1
        fi
    fi

    # Validate and setup (sets RUN_FEATURE_NAME, RUN_FEATURE_DIR, RUN_PRD_FILE)
    run_validate_setup || return 1

    # Dry run mode
    if [[ "$RALPH_DRY_RUN" == true ]]; then
        run_show_dry_run "$RUN_FEATURE_NAME" "$RUN_FEATURE_DIR"
        return 0
    fi

    # Initialize state (circuit breaker, rate limiter, branch)
    run_initialize_state "$RUN_PRD_FILE"

    # Check if already complete
    if all_stories_complete "$RUN_PRD_FILE"; then
        log_success "All stories already complete!"
        if [[ "$RALPH_NO_ARCHIVE" != true ]]; then
            log_info "Archiving feature..."
            cmd_archive
        fi
        return 0
    fi

    # Get timeout command
    local timeout_cmd
    timeout_cmd=$(get_timeout_cmd) || return 1

    # Main loop
    local iteration=0
    log_info "Starting Ralph loop for feature: ${RUN_FEATURE_NAME}"
    log_info "Max iterations: ${RALPH_MAX_ITERATIONS}, Timeout: ${RALPH_TIMEOUT_MINUTES}m"

    while [[ $iteration -lt $RALPH_MAX_ITERATIONS ]]; do
        iteration=$((iteration + 1))

        local iter_result=0
        run_single_iteration "$iteration" "$RUN_FEATURE_DIR" "$RUN_PRD_FILE" "$timeout_cmd" "$RUN_FEATURE_NAME" || iter_result=$?

        case $iter_result in
            0)
                # Continue to next iteration
                sleep 2
                ;;
            1)
                # Error - stop loop
                return 1
                ;;
            2)
                # User exit
                return 2
                ;;
            100)
                # Completion
                return 0
                ;;
        esac
    done

    # Max iterations reached
    log_error "Max iterations (${RALPH_MAX_ITERATIONS}) reached without completion."
    return 1
}

#=============================================================================
# Main Entry Point
#=============================================================================

main() {
    # Check bash version
    check_bash_version

    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        return 0
    fi

    local command="${1:-}"
    shift || true

    case "$command" in
        help|-h|--help)
            show_help
            return 0
            ;;
        version|--version|-V)
            show_version
            return 0
            ;;
        status)
            cmd_status "$@"
            ;;
        archive)
            cmd_archive "$@"
            ;;
        validate)
            cmd_validate "$@"
            ;;
        run)
            cmd_run "$@"
            ;;
        *)
            log_error "Unknown command: ${command}"
            echo "" >&2
            show_help
            return 1
            ;;
    esac
}

# Cleanup function to kill child processes
cleanup() {
    # Show cursor again (in case we were in scrolling window)
    printf '\e[?25h'
    echo ""
    log_warn "Interrupted by user"
    # Kill all child processes in our process group
    pkill -P $$ 2>/dev/null
    # Also kill any claude processes we spawned
    pkill -f "claude -p --permission-mode" 2>/dev/null
    exit 130
}

# Handle Ctrl+C gracefully
trap cleanup INT TERM

# Run main
main "$@"
