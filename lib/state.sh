#!/usr/bin/env bash
# Ralph Hybrid - External State Management Library
# Manages state outside the working tree in ~/.ralph/projects/
#
# This ensures Claude cannot modify Ralph's state (prd.json, progress.log).
# The working tree only contains .ralph/task.md which is read-only to Claude.
#
# Directory Structure:
#   ~/.ralph/
#   ├── config.yaml                    # Global config
#   └── projects/
#       └── {project-hash}/            # Hash of project root path
#           └── {branch}/
#               ├── prd.json           # All stories, completion status
#               ├── spec.md            # Full spec (from planning)
#               ├── progress.log       # Append-only log
#               ├── current_task.md    # Generated per-iteration
#               └── logs/
#                   └── iteration-{N}.log
#
# Working tree (project):
#   └── .ralph/                        # Minimal, gitignored
#       └── task.md                    # Current task only (generated by Ralph)

set -euo pipefail

# Source guard - prevent multiple sourcing
if [[ "${_RALPH_HYBRID_STATE_SOURCED:-}" == "1" ]]; then
    return 0
fi
_RALPH_HYBRID_STATE_SOURCED=1

#=============================================================================
# Constants
#=============================================================================

# Default state directory (can be overridden by RALPH_STATE_DIR env var)
readonly STATE_DEFAULT_DIR="${HOME}/.ralph"

# Working tree ralph directory name
readonly STATE_WORKING_TREE_DIR=".ralph"

# State file names
readonly STATE_PRD_FILE="prd.json"
readonly STATE_SPEC_FILE="spec.md"
readonly STATE_PROGRESS_LOG="progress.log"
readonly STATE_CURRENT_TASK="current_task.md"
readonly STATE_TASK_FILE="task.md"
readonly STATE_LOGS_DIR="logs"

#=============================================================================
# Directory Functions
#=============================================================================

# Get the root state directory
# Returns: Path to ~/.ralph (or RALPH_STATE_DIR if set)
state_get_root_dir() {
    echo "${RALPH_STATE_DIR:-$STATE_DEFAULT_DIR}"
}

# Get the project name from git remote or directory
# Args: project_root_path
# Returns: Project name (e.g., "ralph-hybrid", "my-project")
state_get_project_name() {
    local project_root="$1"

    # Try to get from git remote origin
    local remote_url
    remote_url=$(git -C "$project_root" remote get-url origin 2>/dev/null || echo "")

    if [[ -n "$remote_url" ]]; then
        # Extract repo name from URL
        # Handles: git@github.com:user/repo.git, https://github.com/user/repo.git, etc.
        local repo_name
        repo_name=$(basename "$remote_url" .git)
        echo "$repo_name"
        return
    fi

    # Fall back to directory name
    basename "$project_root"
}

# Get the project state directory for a given project and branch
# Args: project_root branch_name
# Returns: Path to ~/.ralph/projects/{project-name}/{branch}
state_get_project_dir() {
    local project_root="$1"
    local branch="$2"

    local state_root
    state_root=$(state_get_root_dir)

    local project_name
    project_name=$(state_get_project_name "$project_root")

    # Sanitize branch name: convert slashes to dashes
    local sanitized_branch="${branch//\//-}"

    echo "${state_root}/projects/${project_name}/${sanitized_branch}"
}

# Get the project state directory for current working directory and branch
# Returns: Path to state directory
state_get_current_project_dir() {
    local project_root
    project_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        echo "Error: Not in a git repository" >&2
        return 1
    }

    local branch
    branch=$(git branch --show-current 2>/dev/null) || {
        echo "Error: Not on a branch (detached HEAD)" >&2
        return 1
    }

    state_get_project_dir "$project_root" "$branch"
}

#=============================================================================
# State File Accessors
#=============================================================================

# Get path to prd.json in external state
# Args: state_dir (from state_get_project_dir)
# Returns: Path to prd.json
state_get_prd_file() {
    local state_dir="$1"
    echo "${state_dir}/${STATE_PRD_FILE}"
}

# Get path to spec.md in external state
# Args: state_dir
# Returns: Path to spec.md
state_get_spec_file() {
    local state_dir="$1"
    echo "${state_dir}/${STATE_SPEC_FILE}"
}

# Get path to progress.log in external state
# Args: state_dir
# Returns: Path to progress.log
state_get_progress_log() {
    local state_dir="$1"
    echo "${state_dir}/${STATE_PROGRESS_LOG}"
}

# Get path to current_task.md in external state
# Args: state_dir
# Returns: Path to current_task.md
state_get_current_task_file() {
    local state_dir="$1"
    echo "${state_dir}/${STATE_CURRENT_TASK}"
}

# Get path to logs directory in external state
# Args: state_dir
# Returns: Path to logs directory
state_get_logs_dir() {
    local state_dir="$1"
    echo "${state_dir}/${STATE_LOGS_DIR}"
}

# Get path to iteration log file
# Args: state_dir iteration_number
# Returns: Path to iteration log file
state_get_iteration_log() {
    local state_dir="$1"
    local iteration="$2"
    echo "${state_dir}/${STATE_LOGS_DIR}/iteration-${iteration}.log"
}

#=============================================================================
# Working Tree Functions
#=============================================================================

# Get path to .ralph directory in working tree
# Args: project_root (optional, defaults to git root)
# Returns: Path to .ralph/
state_get_working_tree_dir() {
    local project_root="${1:-}"

    if [[ -z "$project_root" ]]; then
        project_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
            echo "Error: Not in a git repository" >&2
            return 1
        }
    fi

    echo "${project_root}/${STATE_WORKING_TREE_DIR}"
}

# Get path to task.md in working tree
# Args: project_root (optional)
# Returns: Path to .ralph/task.md
state_get_task_file() {
    local project_root="${1:-}"
    local working_dir
    working_dir=$(state_get_working_tree_dir "$project_root")
    echo "${working_dir}/${STATE_TASK_FILE}"
}

#=============================================================================
# Initialization Functions
#=============================================================================

# Initialize external state directory structure
# Args: state_dir
# Returns: 0 on success, 1 on failure
state_init() {
    local state_dir="$1"

    # Create directory structure
    mkdir -p "${state_dir}/${STATE_LOGS_DIR}"

    # Initialize progress.log if it doesn't exist
    local progress_log
    progress_log=$(state_get_progress_log "$state_dir")
    if [[ ! -f "$progress_log" ]]; then
        local timestamp
        timestamp=$(date -Iseconds)
        cat > "$progress_log" << EOF
# Progress Log
# Initialized: ${timestamp}
# State Directory: ${state_dir}

EOF
    fi

    return 0
}

# Initialize working tree .ralph directory
# Args: project_root (optional)
# Returns: 0 on success, 1 on failure
state_init_working_tree() {
    local project_root="${1:-}"

    local working_dir
    working_dir=$(state_get_working_tree_dir "$project_root")

    mkdir -p "$working_dir"

    # Add to .gitignore if not already present
    local project_root_actual
    if [[ -z "$project_root" ]]; then
        project_root_actual=$(git rev-parse --show-toplevel 2>/dev/null) || return 1
    else
        project_root_actual="$project_root"
    fi

    local gitignore="${project_root_actual}/.gitignore"
    if [[ -f "$gitignore" ]]; then
        if ! grep -q "^\.ralph/$" "$gitignore" 2>/dev/null; then
            echo ".ralph/" >> "$gitignore"
        fi
    else
        echo ".ralph/" > "$gitignore"
    fi

    return 0
}

#=============================================================================
# Story State Management
#=============================================================================

# Update a story's passes status in prd.json
# This is called by Ralph, never by Claude
# Args: prd_file story_id passes_value [notes]
# Returns: 0 on success, 1 on failure
state_update_story() {
    local prd_file="$1"
    local story_id="$2"
    local passes_value="$3"
    local notes="${4:-}"

    if [[ ! -f "$prd_file" ]]; then
        echo "Error: prd.json not found: $prd_file" >&2
        return 1
    fi

    # Update the story using jq
    local temp_file="${prd_file}.tmp"
    if [[ -n "$notes" ]]; then
        jq --arg id "$story_id" --argjson passes "$passes_value" --arg notes "$notes" '
            (.userStories[] | select(.id == $id)) |= (.passes = $passes | .notes = $notes)
        ' "$prd_file" > "$temp_file" && mv "$temp_file" "$prd_file"
    else
        jq --arg id "$story_id" --argjson passes "$passes_value" '
            (.userStories[] | select(.id == $id)) |= (.passes = $passes)
        ' "$prd_file" > "$temp_file" && mv "$temp_file" "$prd_file"
    fi
}

# Mark a story as complete
# Args: prd_file story_id [notes]
state_mark_story_complete() {
    local prd_file="$1"
    local story_id="$2"
    local notes="${3:-}"
    state_update_story "$prd_file" "$story_id" true "$notes"
}

# Mark a story as incomplete
# Args: prd_file story_id [notes]
state_mark_story_incomplete() {
    local prd_file="$1"
    local story_id="$2"
    local notes="${3:-}"
    state_update_story "$prd_file" "$story_id" false "$notes"
}

# Get the current (first incomplete) story from prd.json
# Args: prd_file
# Returns: JSON object with story details
state_get_current_story() {
    local prd_file="$1"
    jq -r '[.userStories[] | select(.passes == false)][0] // empty' "$prd_file"
}

# Get current story ID
# Args: prd_file
# Returns: Story ID or empty string
state_get_current_story_id() {
    local prd_file="$1"
    jq -r '[.userStories[] | select(.passes == false)][0].id // ""' "$prd_file"
}

# Check if all stories are complete
# Args: prd_file
# Returns: 0 if all complete, 1 if not
state_all_stories_complete() {
    local prd_file="$1"
    local total passed
    total=$(jq '.userStories | length' "$prd_file")
    passed=$(jq '[.userStories[] | select(.passes == true)] | length' "$prd_file")

    [[ "$total" -gt 0 ]] && [[ "$passed" -eq "$total" ]]
}

#=============================================================================
# Progress Logging
#=============================================================================

# Append an entry to progress.log
# Args: state_dir event_type [details...]
# Event types: STARTED, DONE, TESTS_PASSED, TESTS_FAILED, COMPLETE, ERROR
state_log_event() {
    local state_dir="$1"
    local event_type="$2"
    shift 2
    local details="$*"

    local progress_log
    progress_log=$(state_get_progress_log "$state_dir")

    local timestamp
    timestamp=$(date -Iseconds)

    echo "${timestamp} ${event_type} ${details}" >> "$progress_log"
}

# Log story started event
# Args: state_dir story_id
state_log_story_started() {
    local state_dir="$1"
    local story_id="$2"
    state_log_event "$state_dir" "STARTED" "$story_id"
}

# Log iteration done event
# Args: state_dir iteration commit_sha
state_log_iteration_done() {
    local state_dir="$1"
    local iteration="$2"
    local commit_sha="${3:-}"
    state_log_event "$state_dir" "DONE" "iteration=$iteration commits=$commit_sha"
}

# Log tests passed event
# Args: state_dir gate_type
state_log_tests_passed() {
    local state_dir="$1"
    local gate="${2:-perStory}"
    state_log_event "$state_dir" "TESTS_PASSED" "gate=$gate"
}

# Log tests failed event
# Args: state_dir gate_type error_message
state_log_tests_failed() {
    local state_dir="$1"
    local gate="${2:-perStory}"
    local error="${3:-}"
    state_log_event "$state_dir" "TESTS_FAILED" "gate=$gate error=$error"
}

# Log story complete event
# Args: state_dir story_id
state_log_story_complete() {
    local state_dir="$1"
    local story_id="$2"
    state_log_event "$state_dir" "COMPLETE" "$story_id"
}

# Log error event
# Args: state_dir error_message
state_log_error() {
    local state_dir="$1"
    local error="$2"
    state_log_event "$state_dir" "ERROR" "$error"
}

#=============================================================================
# Utility Functions
#=============================================================================

# Check if external state exists for current project/branch
# Returns: 0 if exists, 1 if not
state_exists() {
    local state_dir
    state_dir=$(state_get_current_project_dir 2>/dev/null) || return 1

    local prd_file
    prd_file=$(state_get_prd_file "$state_dir")

    [[ -f "$prd_file" ]]
}

# Get project info from state directory path
# Args: state_dir
# Returns: Project hash and branch name
state_get_info() {
    local state_dir="$1"
    local state_root
    state_root=$(state_get_root_dir)

    # Extract hash and branch from path
    local relative="${state_dir#${state_root}/projects/}"
    local hash="${relative%%/*}"
    local branch="${relative#*/}"

    echo "hash=${hash} branch=${branch}"
}

# List all state directories for a project
# Args: project_root
# Returns: List of branch state directories
state_list_branches() {
    local project_root="$1"
    local state_root
    state_root=$(state_get_root_dir)

    local hash
    hash=$(state_hash_project "$project_root")

    local project_state_dir="${state_root}/projects/${hash}"

    if [[ -d "$project_state_dir" ]]; then
        find "$project_state_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;
    fi
}

# Clean up working tree .ralph directory
# Args: project_root (optional)
state_cleanup_working_tree() {
    local project_root="${1:-}"
    local working_dir
    working_dir=$(state_get_working_tree_dir "$project_root")

    if [[ -d "$working_dir" ]]; then
        rm -rf "$working_dir"
    fi
}
