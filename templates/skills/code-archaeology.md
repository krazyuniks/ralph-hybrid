# Code Archaeology Skill

> **Use when:** Modifying legacy code, investigating unfamiliar codebases, or making changes where unexpected side effects are likely
> **Generated by:** `ralph-plan` when legacy modification patterns detected or explicitly requested

## Purpose

Safely investigate and modify legacy code using a systematic four-role pattern. Each role builds understanding progressively before any changes are made, ensuring modifications don't break existing behavior through hidden dependencies or undocumented assumptions.

---

## Four-Role Pattern

### Role 1: Surveyor (Structural Analyst)

**Goal:** Map the overall structure and boundaries of the code being investigated.

**Tasks:**
1. Identify all files in the relevant module/component
2. Map directory structure and file organization
3. List entry points (public APIs, exported functions, main endpoints)
4. Identify exit points (external calls, database operations, I/O)
5. Count lines of code, complexity metrics
6. Note file ages and last modification dates
7. Identify test coverage (existing tests, test files)

**Output Format:**
```markdown
## Survey Results

### Scope
| Metric | Value |
|--------|-------|
| Files | X |
| Lines of Code | Y |
| Functions/Methods | Z |
| Test Files | W |
| Test Coverage | ~N% |

### Directory Structure
```
target/
├── core/           # Core business logic
├── utils/          # Shared utilities
├── models/         # Data models
└── tests/          # Test files
```

### Entry Points (Public API)
| Location | Type | Usage |
|----------|------|-------|
| module.py:func() | Function | Called from X, Y, Z |
| api/endpoint.py | REST API | External consumers |

### Exit Points (External Dependencies)
| Location | Dependency | Type |
|----------|------------|------|
| db.py:query() | PostgreSQL | Database |
| client.py:fetch() | External API | HTTP |

### Complexity Hotspots
| File | Cyclomatic | Lines | Risk |
|------|------------|-------|------|
| processor.py | 45 | 800 | HIGH |
| utils.py | 12 | 200 | MEDIUM |

### Red Flags
- [ ] No tests for [component]
- [ ] Circular dependencies detected
- [ ] Large file (>500 LOC) without clear separation
- [ ] No documentation for public APIs
```

---

### Role 2: Historian (Change Analyst)

**Goal:** Understand how the code evolved and why decisions were made.

**Tasks:**
1. Review git history for the target files
2. Identify major refactors or rewrites
3. Find relevant commit messages explaining "why"
4. Locate code reviews/PR discussions if available
5. Identify original authors and recent maintainers
6. Track when bugs were introduced and fixed
7. Note patterns in how changes are typically made

**Git Archaeology Commands:**
```bash
# Who wrote what (blame)
git blame -w -C -C -C <file>

# File history with diffs
git log -p --follow -- <file>

# Find when a function was added
git log -S "function_name" --source --all

# Find when a line was deleted
git log -S "deleted_code" --all

# Find commits mentioning a bug/issue
git log --grep="BUG-123" --all

# Show all contributors to a file
git shortlog -sn -- <file>

# Find merge commits affecting file
git log --merges -- <file>
```

**Output Format:**
```markdown
## History Analysis

### Timeline
| Date | Change | Author | Why |
|------|--------|--------|-----|
| 2023-01-15 | Initial implementation | @author1 | Feature X |
| 2023-03-20 | Major refactor | @author2 | Performance issues |
| 2023-06-10 | Bug fix #123 | @author3 | Race condition |

### Key Commits
**[abc1234] 2023-03-20: Refactor processor for performance**
- Changed from synchronous to async processing
- Added batching for database operations
- IMPORTANT: Assumes caller handles errors now

**[def5678] 2023-06-10: Fix race condition in cache**
- Added locking around cache updates
- CRITICAL: Lock order must be maintained

### Authors & Ownership
| Author | Lines | Last Active | Expertise |
|--------|-------|-------------|-----------|
| @author1 | 60% | 2023-01 | Original design |
| @author2 | 30% | 2023-06 | Performance |
| @author3 | 10% | 2023-06 | Bug fixes |

### Notable Patterns
- Changes to X always require changes to Y
- Performance-critical section: lines 100-200
- Known fragile area: caching logic

### Previous Bugs
| Bug | Cause | Fix | Regression Risk |
|-----|-------|-----|-----------------|
| #123 | Race condition | Added locks | HIGH if locks removed |
| #456 | Null reference | Added checks | MEDIUM |
```

---

### Role 3: Archaeologist (Deep Investigator)

**Goal:** Uncover hidden assumptions, undocumented behaviors, and "gotchas" that aren't obvious from the code surface.

**Tasks:**
1. Read the code line-by-line for the critical path
2. Identify implicit assumptions (ordering, state, timing)
3. Find "magic" values and unexplained constants
4. Locate defensive code that suggests past bugs
5. Identify dead code and its original purpose
6. Find coupling between seemingly unrelated components
7. Document tribal knowledge that exists only in code

**Investigation Patterns:**

#### Hidden Assumptions
```python
# ASSUMPTION: items always sorted by date (not documented!)
def process_items(items):
    first = items[0]  # Assumes non-empty AND sorted

# ASSUMPTION: config loaded before this is called
def get_setting(key):
    return _config[key]  # Fails if config not initialized

# ASSUMPTION: called only from main thread
def update_cache(value):
    _cache = value  # Not thread-safe!
```

#### Magic Numbers & Strings
```python
# What is 86400? Why 100?
timeout = 86400  # Seconds in a day (should be constant)
batch_size = 100  # Historical performance tuning (why not 50? 200?)
retry_delay = 5  # Chosen arbitrarily? Or based on rate limits?
```

#### Defensive Code (Past Bug Indicators)
```python
# This None check suggests items was None at some point
if items is not None:  # Why would items be None?
    process(items)

# This try/except suggests this call can fail unexpectedly
try:
    result = fragile_operation()
except Exception:  # What exception? Why catch all?
    result = default_value
```

#### Dead Code Archaeology
```python
# Commented out code - why was it removed? Is it safe to delete?
# old_algorithm(data)  # Removed in PR #456, caused memory issues

# Unreachable code - was this intentional?
def deprecated_feature():
    return  # Early return makes rest unreachable
    cleanup()  # This never runs - is that a bug?
```

**Output Format:**
```markdown
## Archaeological Findings

### Hidden Assumptions
| Location | Assumption | Risk if Violated |
|----------|------------|------------------|
| processor.py:45 | Items pre-sorted | Incorrect results |
| cache.py:100 | Single-threaded access | Data corruption |
| api.py:200 | Auth middleware runs first | Security bypass |

### Magic Values
| Location | Value | Meaning | Source |
|----------|-------|---------|--------|
| config.py:10 | 86400 | Seconds per day | Standard |
| processor.py:50 | 100 | Batch size | Perf testing 2022 |
| retry.py:20 | 5 | Rate limit recovery | Unknown - ASK |

### Past Bug Indicators
| Location | Defensive Code | Probable Past Bug |
|----------|---------------|-------------------|
| user.py:80 | `if user is not None` | Null user from DB |
| api.py:120 | `try/except all` | Unhandled exception |

### Hidden Coupling
| Component A | Component B | Coupling Type |
|-------------|-------------|---------------|
| UserService | EmailService | Must call in order |
| CacheManager | Database | Invalidation dependency |

### Undocumented Behaviors
1. **Order-dependent initialization**: Services must start in A→B→C order
2. **Side effects**: `get_user()` also updates last_access timestamp
3. **Lazy loading**: Config isn't loaded until first access
4. **Caching**: Results cached for 5 minutes (no cache invalidation!)

### Things to Ask About
- [ ] Why is batch_size 100? Can it be changed?
- [ ] Is the try/except in api.py:120 masking real errors?
- [ ] Who decided on the 5-second retry delay?
```

---

### Role 4: Careful Modifier (Safe Change Agent)

**Goal:** Make the requested changes while preserving existing behavior and preventing regressions.

**Tasks:**
1. Write characterization tests BEFORE any changes
2. Identify smallest possible change scope
3. Make changes incrementally with tests at each step
4. Verify no unintended side effects
5. Document any assumptions being changed
6. Update or create documentation for changed behavior

**Modification Protocol:**

#### Step 1: Characterization Tests
```python
# Write tests that capture CURRENT behavior, even if buggy
def test_existing_behavior_items_must_be_sorted():
    """Characterization test: process_items assumes sorted input"""
    items = [Item(date="2023-01-01"), Item(date="2023-01-02")]
    result = process_items(items)
    assert result.first_date == "2023-01-01"

def test_existing_behavior_empty_items_raises():
    """Characterization test: empty items causes IndexError"""
    with pytest.raises(IndexError):
        process_items([])
```

#### Step 2: Scope Minimization
```markdown
## Change Scope Analysis

**Requested Change:** Add support for unsorted items

**Minimum Change Path:**
1. Add sort at entry point (1 line)
2. Add test for unsorted input (5 lines)

**vs. Full Refactor:**
1. Change function signature
2. Update all callers
3. Modify internal logic
4. Update documentation
5. Risk: 50+ files affected

**Recommendation:** Minimum change path
```

#### Step 3: Incremental Changes
```markdown
## Change Plan

### Change 1: Add characterization test
- File: tests/test_processor.py
- Lines: +15
- Risk: NONE (test only)
- Verify: All existing tests pass

### Change 2: Add sort at entry point
- File: processor.py:45
- Lines: +1
- Risk: LOW (additive change)
- Verify: Characterization test passes, existing tests pass

### Change 3: Add test for unsorted input
- File: tests/test_processor.py
- Lines: +10
- Risk: NONE (test only)
- Verify: New test passes
```

#### Step 4: Side Effect Verification
```bash
# Find all callers of changed function
grep -rn "process_items" --include="*.py"

# Check for tests that might be affected
grep -rn "process_items" tests/

# Look for mocks that might need updating
grep -rn "mock.*process_items" tests/
```

**Output Format:**
```markdown
## Modification Report

### Pre-Change Verification
- [x] All existing tests pass (X tests)
- [x] Characterization tests written (Y tests)
- [x] Change scope minimized
- [x] All callers identified

### Changes Made
| File | Change | Lines | Risk |
|------|--------|-------|------|
| processor.py | Added sort | +1 | LOW |
| tests/test_processor.py | Added tests | +25 | NONE |

### Post-Change Verification
- [x] All existing tests pass
- [x] New tests pass
- [x] No unexpected test failures
- [x] No side effects detected

### Documentation Updates
- [ ] README updated (if public API changed)
- [ ] Docstrings updated
- [ ] CHANGELOG entry added

### Rollback Plan
If issues detected:
1. Revert commit [hash]
2. No data migration required
3. No config changes to revert
```

---

## Output Files

The Code Archaeology skill generates three output files:

### SURVEY.md
Contains results from Role 1 (Surveyor):
- File structure and metrics
- Entry/exit points
- Complexity analysis
- Initial risk assessment

### HISTORY.md
Contains results from Role 2 (Historian):
- Git history analysis
- Key commits and their rationale
- Author expertise mapping
- Pattern identification

### GOTCHAS.md
Contains results from Role 3 (Archaeologist):
- Hidden assumptions
- Magic values and their origins
- Past bug indicators
- Undocumented behaviors
- Questions to investigate

### Combined Output Format

Generate all three files, then create a summary:

```markdown
# Code Archaeology Report: [Component/Module Name]

**Investigator:** Code Archaeology Skill
**Date:** [TIMESTAMP]
**Branch:** [BRANCH_NAME]

## Executive Summary

**Risk Level:** HIGH | MEDIUM | LOW
**Recommended Approach:** FULL_INVESTIGATION | TARGETED_CHANGES | SAFE_TO_MODIFY
**Estimated Hidden Complexity:** X assumptions, Y gotchas, Z undocumented behaviors

## Key Findings

### Critical Gotchas
1. [Most dangerous assumption]
2. [Second most dangerous]
3. [Third]

### Safe to Modify
- [List of areas that are well-tested and understood]

### Avoid Touching
- [List of areas that are fragile or poorly understood]

## Linked Reports
- [SURVEY.md](SURVEY.md) - Structural analysis
- [HISTORY.md](HISTORY.md) - Change history
- [GOTCHAS.md](GOTCHAS.md) - Hidden dangers

## Modification Readiness Checklist
- [ ] All roles completed
- [ ] Characterization tests written
- [ ] Change scope minimized
- [ ] Rollback plan documented
```

---

## Quick Archaeology Commands

```bash
# Find all TODO/FIXME/HACK comments
grep -rn "TODO\|FIXME\|HACK\|XXX" --include="*.py" --include="*.js" --include="*.ts"

# Find magic numbers
grep -rn "[^a-zA-Z0-9_][0-9]\{3,\}[^a-zA-Z0-9_]" --include="*.py" --include="*.js"

# Find defensive null checks (suggests past bugs)
grep -rn "if.*is not None" --include="*.py"
grep -rn "if.*!= null" --include="*.js" --include="*.ts"

# Find broad exception catches
grep -rn "except Exception" --include="*.py"
grep -rn "catch\s*(" --include="*.js" --include="*.ts"

# Find commented-out code
grep -rn "^[[:space:]]*#.*[a-zA-Z]\+(" --include="*.py"
grep -rn "^[[:space:]]*//.*[a-zA-Z]\+(" --include="*.js" --include="*.ts"

# Find functions with high parameter counts (complexity indicator)
grep -rn "def.*,.*,.*,.*,.*:" --include="*.py"

# Find deeply nested code (complexity indicator)
grep -rn "^[[:space:]]\{16,\}" --include="*.py" --include="*.js"

# Find file age distribution
find . -name "*.py" -exec stat --format="%Y %n" {} \; | sort -n

# Find files not touched in 6+ months
find . -name "*.py" -mtime +180
```

---

## When to Trigger This Skill

Automatically activate for:
- Changes to files older than 6 months without recent activity
- Modifications to files with no associated tests
- Changes requested to "core" or "legacy" directories
- Tasks mentioning "refactor", "migrate", or "update old"
- Files with high cyclomatic complexity (>20)
- Files with multiple authors and no clear owner
- Bug fixes where root cause is unclear

Keywords that trigger: `legacy`, `old`, `refactor`, `migrate`, `ancient`, `technical debt`, `cleanup`, `modernize`, `understand`, `investigate`, `archaeology`, `history`

---

## Integration with Other Skills

### Before Adversarial Review
Run Code Archaeology first when modifying security-critical legacy code:
1. Archaeology identifies hidden assumptions
2. Security review checks if assumptions are security-relevant

### Before Major Refactors
1. Complete all four archaeology roles
2. Ensure characterization tests exist
3. Then proceed with refactoring

### With Incident Response
When debugging production issues in legacy code:
1. Skip Survey (time-critical)
2. Focus on History (recent changes)
3. Deep-dive Archaeology on suspect areas
4. Careful Modifier for hotfix

---

## References

- "Working Effectively with Legacy Code" by Michael Feathers
- "Refactoring" by Martin Fowler
- Git documentation: https://git-scm.com/docs
- Characterization testing: https://michaelfeathers.silvrback.com/characterization-testing
